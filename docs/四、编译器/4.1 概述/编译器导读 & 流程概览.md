# 编译器导读

编译器的**核心目标将HTML 模板（Template）**生成组件对象中的 `render` 函数。

在之前的章节中我们都要手写**render 函数，无法使用便利可读性较高的模板（Template）文件**

```jsx
// 在 Runtime 阶段，我们需要手写 render 函数
const App = {
  render() {
    return h("div", { id: "app" }, "hello mini-vue");
  },
  setup() { /* ... */ }
};
```

# 流程概览

我们可以把编译器想象成一条**流水线工厂**。它的输入是**模板字符串**，输出是**可执行的代码字符串。主要包括以下的三个步骤**

## 第一步：解析 (Parse)

类似于把一篇英语文章拆解成主语、谓语、宾语。编译器会扫描字符串，识别出哪里是开始标签 `<`，哪里是结束标签 `>`，哪里是插值 `{{ }}`。将**模板字符串**（`<div>hi, {{ msg }}</div>`）输出**AST - 抽象语法树 （深层嵌套的对象，用来描述模板的结构）**

```jsx
// 简化的 AST 样子
{
  type: "ELEMENT",
  tag: "div",
  props: [
	  {
      type: "DIRECTIVE",   // 类型是指令
      name: "if",          // 指令名称是 if (即 v-if)
      exp: "isLoad"
    },
    {
      type: "ATTRIBUTE",   // 普通 HTML 属性
      name: "id",
      value: {
        content: "app"     // 静态值 "app"
      }
    }
  ]
  children: [
    { type: "TEXT", content: "hi, " },
    { type: "INTERPOLATION", content: "msg" } // 插值语法{{msg}}
  ]
}
```

## 第二步：转换 (Transform)

它会遍历这**AST**棵树，**对它进行增删改查**。

- 比如发现 `v-if`，就把它转换成三元表达式结构。
- 比如发现 `v-for`，就把它转换成循环列表结构。
- Vue 3 的静态提升（hoistStatic）和补丁标记（PatchFlags）优化也发生在这里。

**最后的输出结果是CodegenNode (代码生成节点)**。这是为了方便最后一步生成代码而专门转化的一种更接近 JavaScript 代码逻辑的 AST 变体。如下所示

```jsx
{
  type: "JS_CONDITIONAL_EXPRESSION", // 代表这是一个三元表达式
  test: { type: "SIMPLE_EXPRESSION", content: "isLoad" }, // v-if 的条件
  
  // 如果 isLoad 为 true，执行这部分（consequent）
  consequent: {
    type: "VNODE_CALL", // 对应渲染函数中的 h('div', ...)
    tag: '"div"',
    props: '{ id: "app" }', // 普通属性被提取出来了
    
    // 原来的 children 在这里，原封不动地带过来了
    children: [
      { type: "TEXT", content: '"hi, "' },
      { 
        type: "INTERPOLATION", 
        content: { content: "msg" } // 插值也被保留了
      }
    ],

    // 顺便打个补丁标记：告诉运行时只有文本子节点会变
    patchFlag: "1 /* TEXT */"
  },

  // 如果 isLoad 为 false，执行这部分（alternate）
  alternate: {
    type: "VNODE_CALL",
    tag: "CREATE_COMMENT", // 生成一个注释节点防止 DOM 结构乱掉
    children: '"v-if"'
  }
}
```

## 第三步：代码生成 (Codegen)

转换后的 CodegenNode**生成最终的render字符串**。

```jsx
// 最终生成的字符串看起来像这样，不过一般不会写h，会写h的各种封装
"function render(_ctx) {
  return (
    _ctx.isLoad 
      ? h("div", { id: "app" }, [
          "hi, ",             // 纯文本直接写，或者 h(undefined, "hi, ")
          _ctx.msg            // 插值变量
        ])
      : h("!--", "v-if")      // 注释节点占位
  )
}"
```

注：解析模板确实是完完全全实现的，并没有借助任何第三方的现成 AST 解析库