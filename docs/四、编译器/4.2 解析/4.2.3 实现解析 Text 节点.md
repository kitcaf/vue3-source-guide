# 实现解析 Text 节点 (Parse Text)

**解析 Text 节点**，指的是在扫描模板字符串时，将普通的纯文本提取出来，转换成对应的 AST 节点。
比如对于模板 `<div>hello world</div>`，当字符串吃 `<div>` 后，剩下的 `hello world</div>` 中，`"hello world"` 就是一个纯文本。我们需要把它解析成如下结构的 AST 节点：

```tsx
{
  "type": "TEXT",
  "content": "hello world"
}
```

## 实现

当前字符串全是文本，但文本到哪里结束呢？答案是：**遇到下一个 `<`（标签）或者 `{{`（插值）的时候，就是当前文本结束的位置**

### 第一步：补充 AST 节点类型 (Types & Interfaces)

把具体的接口定义出来

```tsx
 //\packages\compiler-core\src\ast.ts
export const enum NodeTypes {
    INTERPOLATION,  // 插值节点 {{ }}
    SIMPLE_EXPRESSION, // 简单表达式节点（属于插值节点的子类型 - content里面的type子类型）
    ELEMENT, // 新增：元素节点类型
    TEXT // 【新增】纯文本节点
}
export interface TextNode {
    type: NodeTypes.TEXT
    content: string;
}
```

### 第二步：实现 `parseText` 核心逻辑

核心：需要找到离当前位置最近的 `<` 或 `{{`。

```tsx
//\packages\compiler-core\src\parse.ts
/**
 * 解析文本节点
 * @param context 
 */
function paeseText(context: ParserContext): TextNode {
    // 默认endIndex的位置为最大，所有的长度
    let endIndex = context.source.length
    const endTokens = ["<", "{{"]

    // 从这两种endTokens中找一个最近的位置
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i])
        // 更新endIndex, 注意indexOf没有找到返回-1
        if (index !== -1 && index < endIndex) {
            endIndex = index
        }
    }
    // 进行切分文本部分
    const content = context.source.slice(0, endIndex)

    // 吃掉字符串部分
    advanceBy(context, content.length);

    return {
        type: NodeTypes.TEXT,
        content: content
    }
}
```