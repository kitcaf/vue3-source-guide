# 实现解析插值

插值（*Interpolation*）指的是模板中用来绑定动态数据的双大括号语法 `{{ }}`。

**解析插值**，就是在编译的 Parse（解析）阶段，扫描模板字符串（例如 `<div>{{ message }}</div>`），当遇到 `{{` 时，将其及其内部的内容截取出来，并将它转换成一个特定结构的 **AST（抽象语法树）节点**（即一个描述该插值的 JavaScript 对象）。

例如，遇到 `{{ message }}` 时，我们要把它解析成类似下面这样的对象：

```jsx
{
  "type": "INTERPOLATION",
  "content": {
    "type": "SIMPLE_EXPRESSION",
    "content": "message"
  }
}
```

## 实现

解析的过程其实就是一个**字符串不断被消费（截取）的过程**。

当遇到”{{” 解析插值的开头字符时就进行的**解析插值函数（`parseInterpolation`）**的调用（**因此通常此时的上下文是"{{ message }}</div>…”**）

### 第一步：定义 AST 节点类型 (Types & Interfaces)

在解析插值时，会产出两种节点：**一个是插值节点本身**，另一个是**插值内部的表达式节点（可能是简单表达式也可能是js表达式）**。需要为它们定义清晰的接口。

```jsx
// \packages\compiler-core\src\ast.ts
// 定义所有可能出现的 AST 节点类型枚举
export const enum NodeTypes {
    INTERPOLATION,  // 插值节点 {{ }}
    SIMPLE_EXPRESSION // 简单表达式节点（属于插值节点的子类型 - content里面的type子类型）
}

// 简单表达式节点的类型接口
export interface SimpleExpressionNode {
    type: NodeTypes.SIMPLE_EXPRESSION
    content: string // 例如 "message"
}

// 插值节点的类型接口
export interface InterpolationNode {
    type: NodeTypes.INTERPOLATION,
    content: SimpleExpressionNode
}
```

### 第二步：定义解析器上下文类型和实现字符串推进函数

解析器在运行过程中需要维护当前的状态(最核心的就是**剩下哪些字符串没有解析)**，同时构建一个实现**字符串推进函数**用于将处理过的字符串从上下文中**吃掉**

```jsx
// \packages\compiler-core\src\parse.ts
// 定义解析上下文的接口
export interface ParserContext {
    source: string
}

/**
 * 返回编译器的解析上下文
 * @param content 最原始的字符串
 * @returns 
 */
export function createParserContext(content: string): ParserContext {
    return {
        source: content
    }
}

/**
 * 消费（截取）前面部分指定长度的字符串
 * 比如“{{message}}” 消费2，就是"message}}"
 * @param context 
 * @param length 
 */
function advanceBy(context: ParserContext, length: number): void {
    context.source = context.source.slice(length)
}
```

### 第三步：实现核心函数 `parseInterpolation`

当我们的主循环识别到字符串是以 `{{` 开头时，就会调用这个函数。
具体的流程是：找头 -> 找尾 -> 截取中间 -> 祛除两边大括号 -> 祛除空格 -> 返回 AST 节点。

注：后期调用运行该函数**的前提一定是**`ParserContext.source`**检测到当前以”`{{`” 开始（类似"`{{ message }}</div>…`”）**

```jsx
//  \packages\compiler-core\src\parse.ts
/**
 * 解析插值 {{ }} 
 * @param context context 解析器上下文
 */
export function parseInterpolation(context: ParserContext): InterpolationNode {
    const openDelimiter = "{{"
    const closeDelimiter = "}}"

    // 找closeDelimiter的位置"}}"，返回的是第一个}的下标
    // 从 openDelimiter.length (即 2) 的位置开始找，跳过开头的 "{{"
    let closeIndex = context.source.indexOf(closeDelimiter,
        openDelimiter.length
    )

    // =========== 错误处理 =============
    if (closeIndex === -1) {
        // 省略错误保持
        // 容错恢复：既然找不到 "}}"，我们就假设从 "{{" 后面一直到整个字符串结束，都是这个插值的内容。
        closeIndex = context.source.length;
    }

    // 吃掉开头的 "{{"
    advanceBy(context, openDelimiter.length)

    // 计算内部表达式的长度
    // 例如 "{{ message }}"，此时 source 是 " message }}"
    // closeIndex 原本是 11，减去 "{{" 的长度 2，内部长度为 9
    const rawContentLength = closeIndex - openDelimiter.length

    // 提取出原始的内容
    const rawContent = context.source.slice(0, rawContentLength)

    // 将这部分内部内容从上下文的字符串中吃掉
    advanceBy(context, rawContentLength)

    // 剔除表达式前后的空格，得到纯净的变量名
    const content = rawContent.trim()

    // 吃掉结尾的 "}}"
    advanceBy(context, closeDelimiter.length)

    // 返回解析插值节点
    return {
        type: NodeTypes.INTERPOLATION,
        content: {
            type: NodeTypes.SIMPLE_EXPRESSION,
            content: content
        }
    }
}
```