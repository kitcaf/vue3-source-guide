# 联合解析与有限状态机

> 说白了我们要**结合前面的3个核心函数，完成对模板解析的完整操作**

**联合解析**指的是扫描一段包含多种语法的模板（如 `<div>hello {{ msg }}</div>`）时，能够自动识别并调用对应的独立解析函数，最终将平铺的字符串转换成一个包含层级关系的 AST 节点数组（`ASTNode[]`）

**有限状态机 (FSM)** 是这里运用的核心设计模式。在解析过程中，解析器像一个状态机，它始终“盯着”当前字符串的首个（或前几个）字符：

- 如果看到 `<`，且后面跟着字母，状态切换为解析元素。
- 如果看到 `{{`，状态切换为解析插值。
- 如果都不是，状态切换为解析文本。

**每一次解析完毕，字符串被吃掉一部分**，状态机再次重新判断，直到字符串被吃光或者遇到结束条件

如果我们将解析插值和解析文本看成是一类（html标签包裹的内容），本质上就是一个**html闭合标签的括号匹配转树结构问题**

## 回顾经典的括号匹配

假设我们有一串字符：`( [ ] )`，判断它是否合法。

我们的标准解法是引入一个**栈（Stack）**：

- 遇到左括号 `(`：**压栈**，栈变成 `['(']`。
- 遇到左括号 `[`：**压栈**，栈变成 `['(', '[']`。
- 遇到右括号 `]`：查看栈顶是不是 `[`。如果是，匹配成功，**出栈**，栈变成 `['(']`。
- 遇到右括号 `)`：查看栈顶是不是 `(`。如果是，匹配成功，**出栈**，栈变成 `[]`。
- 遍历结束，栈为空，说明括号完全匹配！

**注意核心动作**：左括号 = 进栈，右括号 = 出栈。

### 将 HTML 映射为括号

现在，把普通的括号换成 HTML 标签，加入普通内容（文本/插值）：字符串：`<div> <span> 文本 </span> </div>`

映射关系：

- `<div>` = 左大括号 `{`
- `<span>` = 左中括号 `[`
- `文本` = 括号里无关紧要的数字，比如 `{[ 123 ]}`
- `</span>` = 右中括号 `]`
- `</div>` = 右大括号 `}`

可以发现是很**类似结构**

## 实现思路

虽然和括号匹配的结构很类似，但是我们的终极目标是**把平铺的字符串，变成一棵带有嵌套层级关系的 AST 树（对象），以**`<div><span>{{msg}}</span><p>文本</p>文本1<p></p></div>`为例，最后希望得到的结构（图示-对应的对象结构也是如此）应该是如下：

![image.png](attachment:43232dab-86ad-4a7c-9319-d99778a1a6e4:image.png)

也就是说它本质是一个**递归字符串构建树问题。原理就是从root开始递归，递归它的所有子节点，直到递归叶子节点。**

### **核心问题**：

- **递归它的所有子节点这个while循环怎么写？或者说（它有哪些子节点，怎么判断子节点结束了）**

回到“括号匹配”思维，`<div><span>{{msg}}</span><p>文本</p>文本1<p></p></div>`  什么时候它的子节点结束**一定是它的第一个html闭合标签，**`<div>` 如果在栈中遍历到了`</div>` 就表示它的子节点完全结束了，`<p>` 也是遇到第一个`</p>` **也表示子节点完全结束**

- 栈的表示形式（**能不能使用全局变量维护栈**）

不能，应该**作为参数传递 或者 放在 Context 中。原因：**JavaScript 虽然是单线程的，但在 Node.js 环境下（比如使用 Vite 打包你的 Vue 项目，或者在做 SSR 服务端渲染时），由于大量的异步 I/O 操作，**编译器可能会在同一时间处理多个 Vue 文件**。**多个 Vue 文件使用同一个栈空间，整个编译彻底崩溃，各种标签闭合错乱。**

## 实现

### 第一步：实现 `isEnd` 结束判断逻辑

> **判断是否所有子节点结束的函数**
> 
- 字符串解析完了（`context.source` 为空）**从最顶层的root一定通过这个判断的**
- **遇到了结束标签**，并且这个结束标签和我们祖先栈（`ancestors`）里的某个标签匹配上

```tsx
/**
 * 判断子节点是否为空
 * 第一次：parseChildren是判断context字符串不为空
 * 后面：通过栈来判断，</, 遇到进行判断是否是栈顶元素如果是，那么表示结束了
 * @param context 
 * @param ancestors 栈
 */
function isEnd(context: ParserContext, ancestors: string[]): boolean {
    const s = context.source;
    if (s.startsWith("</")) {
        // 从栈顶向下寻找，看看有没有匹配的祖先标签
        // 这样做是为了容错：如果用户写了 <div><span></div> (漏了 </span>)
        // 状态机会直接向上查找到 div，从而强行结束 span 的解析，避免死循环
        for (let i = ancestors.length - 1; i >= 0; i--) {
            if (s.startsWith(`</${ancestors[i]}>`)) {
                return true
            }
        }
    }
    // 如果字符串被消费光了，也结束
    return !s
}
```

### 第二步：实现主循环 `parseChildren`

> 也就是**返回当前层的Children节点**
> 

它的使命只有一个：**构建当前这一层父节点的 `children` 数组**。每一层的 `while` 循环绝对不能等到整个栈为空才结束，它必须在遇到属于这一层的结束标签时，就立刻结束自己当前的循环（也就是`isEnd` 函数）

```tsx
/**
 * 返回当前层的Children节点
 * 结束条件：字符串空了或者栈匹配到了当前层的元素
 * @param context
 * @param ancestors 
 */
export function parseChildren(context: ParserContext, ancestors: string[]): ElementNode[] {
    const node: ASTNode[] = []

    // 遍历它的所有子节点
    while (!isEnd(context, ancestors)) {
        // ELement子节点 - 内层会继续递归它的子节点（这里判断全一点必须<+字母）
        if (context.source[0] === "<" && /[a-z]/i.test(context.source[1])) {
            /**
             * 第一次调用也就是isEnd（字符串）开启一个循环
             * 后面的parseChildren一定是parseElement引起的，
             * 而要获取本层的节点标签一定是parseElement，因此ancestors在parseElement里面进行处理
             */
            node.push(parseElement(context, ancestors))
        }
        // {{}} 解析插值叶子节点
        else if (context.source.startsWith("{{")) {
            node.push(parseInterpolation(context))
        }
        // 文本叶子节点
        else {
            node.push(parseText(context))
        }
    }
    return node
}
```

### 第三步：修改**`parseElement`**

**加入对栈的调用**

```tsx
export function parseElement(context: ParserContext, ancestors: string[]): ElementNode {
		...
    // 处理子元素 【占位符 - parseChildren、后续章节实现其实就是while循环-去继续递归子元素】
    if (!element.isSelfClosing) {
        // 递归本节点的所有子元素
        ancestors.push(element.tag) // 将本元素的标签放入ancestors
        element.children = parseChildren(context, ancestors);
        ancestors.pop() // 恢复现场
			  ...
    }
    return element
}
```