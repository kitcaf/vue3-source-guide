# 实现解析 Element 节点

**解析 Element 节点**，指的是在扫描模板字符串时，遇到形如 `<div>` 的 HTML 标签，将其解析成一个描述该元素的 **AST（抽象语法树）节点**。
比如，对于模板 `<div id="app"></div>`（**我们先不考虑属性，只看标签**），要将其转换为如下结构的对象：

```jsx
{
  "type": "ELEMENT",    // 节点类型：元素
  "tag": "div",         // 标签名
  "tagType": "ELEMENT", // 标签类型（还会区分是原生元素 ELEMENT，还是组件 COMPONENT）
  "children": []        // 它的子节点（可能是文本、插值、或其他 Element）
}
```

HTML 的本质是**树形嵌套结构**。**解析元素**是构建这棵树的**骨架**。只有识别出了开始标签 `<tag>` 和结束标签 `</tag>`，才能知道哪些内容是包裹在这个元素内部的（即它的 children )

## 实现

解析元素的套路比较固定：**解析开始标签 -> 解析子节点（递归） -> 解析结束标签**

在这个过程中，我们需要依赖**正则表达式**来匹配标签名，并结合前面的 `advanceBy` 函数不断吃掉处理完的字符串。

### 第一步：补充 AST 节点类型 (Types & Interfaces)

```jsx
// \packages\compiler-core\src\ast.ts
// 定义所有可能出现的 AST 节点类型枚举
export const enum NodeTypes {
    INTERPOLATION,  // 插值节点 {{ }}
    SIMPLE_EXPRESSION, // 简单表达式节点（属于插值节点的子类型 - content里面的type子类型）
    ELEMENT, // 新增：元素节点类型
}

// 区分元素的具体类型（原生元素、组件等）- 是一个枚举类型
export const enum ElementTypes {
    ELEMENT,   // 原生 HTML 元素，比如 div, span
    COMPONENT, // Vue 组件（后续扩展用）
}

export type ASTNode = ElementNode | any /* 暂用占位，代表其他类型节点 */;

export interface ElementNode {
    type: NodeTypes.ELEMENT
    tag: string
    tagType: ElementTypes
    children: ASTNode[]
}
```

### 第二步：解析标签

遇到开始标签（`<div...>`）需要返回一个ElementNode节点，而对于对应标签的结束标签则不需要返回。**两者都要“吃”掉对应的字符串标签**

- 由于开始标签 `<div...>` 和结束标签 `</div...>` 的**解析逻辑高度相似**，会写一个通用的 `parseTag` 函数，因此需要一个枚举来区分当前是在解析哪种标签

```tsx
// packages\compiler-core\src\parse.ts
const enum TagType {
    Start, // 开始标签
    End //结束标签
}
```

- 实现底层的 `parseTag` 函数，**负责利用正则提取标签名（开始标签/结束标签）**，并且把 `<div` 和尾部的 `>` 都从上下文中吃掉

```tsx
// \packages\compiler-core\src\parse.ts
/**
 * 解析单个标签（开始标签或结束标签）
 * @param context context 解析器上下文
 * @param type type 当前要解析的是开始还是结束标签
 */
function parseTag(context: ParserContext, type: TagType)
     : ElementNode // 自闭和标签需要返回给调用者不需要回调它的子类了
    | undefined {
    // 1. 编写正则匹配标签名
    // 如果是开始标签，匹配 /^<([a-z][^\t\r\n\f />]*)/i  (例如: "<div")
    // 如果是结束标签，匹配 /^<\/([a-z][^\t\r\n\f />]*)/i (例如: "</div")
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    if (!match) return undefined
    // 提取标签名 正则的捕获组div
    const tag = match[1];
    // 吃掉匹配到的部分，例如 "<div" match[0]是整个捕获的字符串
    advanceBy(context, match[0].length)
    // 吃标签闭合的 ">" 或者 "/>"（自闭合标签）
    const isSelfClosing= context.source.startsWith("/>")
    advanceBy(context, isSelfClosing? 2 : 1)
    if (type === TagType.End) {
        return undefined
    }
    return {
        type: NodeTypes.ELEMENT,
        tag: tag,
        tagType: ElementTypes.ELEMENT, // 这里先默认都是原生元素
        children: [],
        isSelfClosing// 是否是自闭合
    }
}
```

### 第三步：实现 `parseElement` 主流程

> 将**开始标签**、**内部子节点**、**结束标签**串联起来
> 

本质就是一个递归，先对parseTag**处理开始标签**获得ElementNode，然后递归子元素补齐children，最后对使用parseTage**处理结束标签**

```tsx
// \packages\compiler-core\src\parse.ts
/**
 * 解析完整的 Element 节点
 * @param context 
 */
export function parseElement(context: ParserContext): ElementNode {
    // 解析开始标签
    // 此时 context.source 比如是 "<div>hello</div>"
    // 执行后，element 拿到 AST 节点，context.source 变成 "hello</div>"
    const element = parseTag(context, TagType.Start);

    if (!element) {
        throw new Error('Failed to parse start tag.');
    }

    // 处理子元素 【占位符 - parseChildren、后续章节实现其实就是while循环-去继续递归子元素】
    if (!element.isSelfClosing) {

        element.children = parseChildren(context);

        // 校验结束标签是否与开始标签匹配
        if (context.source.startsWith(`</${element.tag}>`)) {
            parseTag(context, TagType.End);
        } else {
            throw new Error(`缺少结束标签: </${element.tag}>`);
        }
    }
    return element
}
```