# 总入口`baseParse`

`baseParse` 是编译器的**总入口函数**。它接收用户传入的最原始的模板字符串（`content`），在内部初始化上下文，然后调用 `parseChildren` 拿到所有的 AST 节点，最后把这些节点包裹在一个 **`RootNode` (根节点)** 对象中返回。

**Vue 3支持多根节点（Fragment）**：用户的模板可能是 `<div>1</div> <span>2</span>`。`parseChildren` 解析后会返回一个包含 2 个元素的数组 `[divNode, spanNode]`。我们需要一个统一的 `ROOT` 节点来把这个数组“包”起来，形成一棵**只有唯一树根**的抽象语法树。

## 实现

### 第一步：在 `ast.ts` 中补充 ROOT 类型

```tsx
// 定义所有可能出现的 AST 节点类型枚举
export const enum NodeTypes {
    INTERPOLATION,  // 插值节点 {{ }}
    SIMPLE_EXPRESSION, // 简单表达式节点（属于插值节点的子类型 - content里面的type子类型）
    ELEMENT, // 新增：元素节点类型
    TEXT, // 纯文本节点
    ROOT 【新增】
}

export interface RootNode {
    type: NodeTypes.ROOT;
    children: ASTNode[];
}
```

### 第二步：入口文件

```tsx
/**
 * 包装生成 Root 节点
 * @param children 子节点数组
 */
function createRoot(children: ASTNode[]): RootNode {
    return {
        type: NodeTypes.ROOT,
        children: children
    }
}

/**
 * 【最终入口】解析模板字符串，生成 AST 树
 * @param content 原始模板字符串
 * @returns 完整的 AST 根节点
 */
export function baseParse(content: string): RootNode {
    // 创建全局唯一的解析上下文
    const context = createParserContext(content)

    // 将整个模板作为一个整体，调用 parseChildren 进行联合解析
    // 最外层解析时，ancestors 祖先栈肯定是空的 []，此时的判断一定是字符串是否为空
    const children = parseChildren(context, []);
    return createRoot(children)
}
```