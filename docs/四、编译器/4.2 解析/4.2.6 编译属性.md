# 解析属性

**解析属性**指的是，在解析 Element 的**开始标签**时（比如遇到 `<div id="app" class="box">`），除了把 `div` 这个标签名提取出来，还要把后面的 `id="app"` 和 `class="box"` 解析成对应的 AST 节点，并存放在当前 Element 节点的 `props` 数组中。未来可以记录节点的特征和

最终生成的 Element AST 应该长这样：

```tsx
{
  "type": "ELEMENT",
  "tag": "div",
  "props": [
    { "type": "ATTRIBUTE", "name": "id", "value": { "type": "TEXT", "content": "app" } },
    { "type": "ATTRIBUTE", "name": "class", "value": { "type": "TEXT", "content": "box" } }
  ],
  "children": []
}
```

## 实现

属性一定存在**开始标签名之后**，**闭合的 `>` 或 `/>` 之前**

因此，这个逻辑要插在 `parseTag` 函数内部。我们需要写一个 `while` 循环，只要还没碰到 `>` 和 `/>`，就一直把当前的字符串当成属性“吃”掉。

### 第一步：在 `ast.ts` 补充属性相关的类型

```tsx
// packages\compiler-core\src\ast.ts
export const enum NodeTypes {
    INTERPOLATION,  // 插值节点 {{ }}
    SIMPLE_EXPRESSION, // 简单表达式节点（属于插值节点的子类型 - content里面的type子类型）
    ELEMENT, // 新增：元素节点类型
    TEXT, // 纯文本节点
    ROOT,
    ATTRIBUTE // 【新增】 属性节点
}
export interface AttributeNode {
    type: NodeTypes.ATTRIBUTE;
    name: string; // 属性名，比如 "id"
    value: TextNode | undefined; // 属性值，比如 "app"。也可能没有值（如 disabled）
}
export interface ElementNode {
    type: NodeTypes.ELEMENT
    tag: string
    tagType: ElementTypes
    props: AttributeNode[], 【新增】
    children: ASTNode[]
    isSelfClosing?: boolean
}
```

### 第二步：实现解析空格和解析属性的函数

- **去除空格**，因为我们直到属性a=’b’ 属性之间存在空格，属性与边界也是存在空格的，因此要删除字符串前面的空格

```tsx
//compiler-core\src\utils.ts
/**
 * 吃掉前面的空格
 */
export function advanceSpaces(context: ParserContext): void {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
```

- 解析单个属性（比如 `id="app”`），原理就是通过正则匹配匹配属性名（=），字符串查找匹配属性值就可以了

```tsx
// packages\compiler-core\src\parse.ts
/**
 * 解析单个属性，比如 id="app"
 * @param context 
 */
function parseAttribute(context: ParserContext): AttributeNode {
    // 匹配属性名
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)!;
    if (!match) {
        throw new Error(`解析属性失败，遇到意外的字符: ${context.source[0]}`);
    }
    const name = match[0];
    advanceBy(context, name.length);

    // 匹配属性值
    // 解析属性值 (有可能没有值，比如 <input disabled>)
    let value: any = undefined;

    // 如果后面紧跟=，说明是有属性值的
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        //吃掉空格
        advanceSpaces(context);
        // 吃掉=号
        advanceBy(context, 1);
        // 吃掉=号后面的空格
        advanceSpaces(context);

        // 属性值是""/''。包裹

        // 获取当前引号类型（是单引号还是双引号）
        const quote = context.source[0]
        const isQuote = quote === `"` || quote === `'`;

        if (isQuote) {
            // 消费引号
            advanceBy(context, 1);
            // 找到结束引号位置
            let endQuoteIndex = context.source.indexOf(quote)
            if (endQuoteIndex > -1) {
                const valueContent = context.source.slice(0, endQuoteIndex);
                value = {
                    type: NodeTypes.TEXT,
                    content: valueContent
                };
                advanceBy(context, valueContent.length + 1);
            }
        }
    }
    return {
        type: NodeTypes.ATTRIBUTE,
        name: name,
        value
    }
}
```

- 解析当前标签内的所有属性，本质上就是一个while循环，去不断调用parseAttribute

```tsx
/**
 * 遍历标签中的所有属性
 * @param context 
 */
function parseAttributes(context: ParserContext): AttributeNode[] {
    const props: AttributeNode[] = []

    while (context.source.length > 0 &&
        !context.source.startsWith(">") &&
        !context.source.startsWith("/>")) {
        // 先消费空格
        advanceSpaces(context)
        // 获取一个属性
        const prop = parseAttribute(context)
        // 加入数组
        props.push(prop)
        // 消费下一个属性之前的空格
        advanceSpaces(context)
    }
    return props
}
```

### 第三步：将 `parseAttributes` 嵌入到 `parseTag` 中

因为标签是在`parseTag` 处理的，因此需要将最终解析属性的时候放入`parseTag` 

```tsx
/**
 * 解析单个标签（开始标签或结束标签）
 * @param context context 解析器上下文
 * @param type type 当前要解析的是开始还是结束标签
 */
function parseTag(context: ParserContext, type: TagType)
    : ElementNode // 自闭和标签需要返回给调用者不需要回调它的子类了
    | undefined {
    // 1. 编写正则匹配标签名
    // 如果是开始标签，匹配 /^<([a-z][^\t\r\n\f />]*)/i  (例如: "<div id="app">")
    // 如果是结束标签，匹配 /^<\/([a-z][^\t\r\n\f />]*)/i (例如: "</div>")
    // <div id="app"> match[1]=div  match[0]=<div
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    if (!match) return undefined
    const tag = match[1];
    advanceBy(context, match[0].length)
    
    // 消费属性 id="app"> 【新增】
    advanceSpaces(context)
    let props: AttributeNode[] = [];
    if (type === TagType.Start) {
        props = parseAttributes(context)
    }

    // 吃标签闭合的 ">" 或者 "/>"（自闭合标签）
    const isSelfClosing = context.source.startsWith("/>")
    advanceBy(context, isSelfClosing ? 2 : 1)

    if (type === TagType.End) {
        return undefined
    }

    return {
        type: NodeTypes.ELEMENT,
        tag: tag,
        tagType: ElementTypes.ELEMENT, // 这里先默认都是原生元素
        children: [],
        props: props, 【新增】
        isSelfClosing: isSelfClosing // 是否是自闭合
    }
}
```