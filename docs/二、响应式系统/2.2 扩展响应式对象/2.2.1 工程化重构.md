# 工程化重构

目前我们的 `reactive.ts` 里面，`new Proxy` 的第二个参数（Handler 对象）是直接写死在函数里的

```typescript
// 现在的写法 (Hardcoded)
export function reactive(raw) {
    return new Proxy(raw, {
        get() { ... }, // 逻辑写死在这里
        set() { ... }  // 逻辑写死在这里
    })
}
```

会造成两个问题：（1）代码复用率低，`reactive` 和 将要实现的`readonly` 的 `get` 逻辑有 90% 是相同的（都要用 `Reflect.get` 取值）（2）**函数创建开销**，如果在 `reactive` 内部定义 `get/set` 函数，每次调用 `reactive` 都会重新创建这两个函数对象，因为这两个对象其实本质都没有调用this, 也就是说它并不是某个对象特有的，转换为**静态函数成员（抽取为独立的函数）**，**可以避免每次创建**

**解决方案：高阶函数 + 工厂模式  + 闭包**

- 新建packages/reactivity/src/baseHandlers.ts文件并使用 `createGetter` 和 `createSetter` 工厂函数

```typescript
import { track, trigger } from "./effect";

export function createGetter() {
    return function getter(target: any, key: string | symbol, receiver: any) {
        console.log(`Proxy getter触发 ${String(key)} ${target}`)
        // const res = target[key]
        const res = Reflect.get(target, key, receiver)
        track(target, key)
        return res
    }
}

export function createSetter() {
    return function set(target: any, key: string | symbol, newValue: any, receiver: any) {
        console.log(`Proxy setter触发 ${key as String} ${target}`)
        // target[key] = newValue
        const res = Reflect.set(target, key, newValue, receiver)
        trigger(target, key)
        return true
    }
}

// 执行一次，这个对象创建之后就不会再创建了，相当于就是静态的
const get = createGetter();
const set = createSetter();

/**
 * 导出 mutableHandlers对象 - 不变的 (给 reactive 用)
 */
export const mutableHandlers = {
    get,
    set
}; // \packages\reactivity\src\reactive.ts 中的改为return new Proxy(raw, mutableHandlers)

```