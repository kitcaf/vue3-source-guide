# 2.2.4 实现 reactive 和 readonly 嵌套对象转换功能 - 深层代理

Vue 3 响应式系统中最迷人、也是设计最精巧的地方之一：**“懒代理” (Lazy Proxy)** 机制

> 一句话概括：**Vue 3 默认不会把一个多层嵌套的对象一次性全变成响应式，而是“访问到哪里，代理哪里，如果某个多层嵌套的对象中的某个对象从来没有在effect函数函数参数中访问，那么就不代理”**
> 

在之前的的代码中，`createGetter` 拿到 `res = Reflect.get(...)` 后直接返回了`res`
如果我们定义 `const proxy = reactive({ a: { b: 1 } c: {d: 1}})`

- 然后在effect函数参数`proxy.a`，得到的是原生对象 `{ b: 1 }`
- 既然是原生对象，你修改 `proxy.a.b = 2`，**由于原生对象没有被 Proxy 拦截，所以不会触发 trigger**
- **结果：** 响应式丢失了
- 注意：在这个例子其实我们又不希望`proxy.c`这个对象不被响应式，因为它都没有访问过嘛

**实现步骤：**

- 准备工具函数 (Prerequisite)， 判断是不是对象

```typescript
//packages/shared/src/index.ts
// 判断是否是对象
export function isObject(val: any) {
    return val != null && typeof val === 'object'
}
```

- 改造 Handler (Implementation)：建立递归链路，不需要对整个对象进行递归，而是根据最后的访问结果进行递归，**注意**  `track(target, key)` 要先执行（保存返回之前收集了依赖）

```typescript
//packages/reactivity/src/baseHandlers.ts
export function createGetter(isReadonly = false) {
    // target (Object): 原生对象 
    // key (String | Symbol): 属性名
    //  receiver (Object): 代理对象本身
    return function getter(target: any, key: string | symbol, receiver: any) {
        ...
        const res = Reflect.get(target, key, receiver)

			  //注意isObject(res)要isObject(res)之前
        if (!isReadonly) track(target, key)
        
        // 根据返回值res判断，如果res是对象，需要再根据这个对象建立响应式
        // 最后要不要返回响应式对象，或者需不需要将obj = {a: { b : 1}}
        // 改为obj.a的指针改为proxy对象
        if (isObject(res)) {
            return isReadonly ? reactive(res) : readonly(res)
        }
        return res
    }
}
```