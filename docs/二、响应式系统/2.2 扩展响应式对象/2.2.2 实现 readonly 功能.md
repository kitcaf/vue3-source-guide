# 2.2.2 实现 readonly 功能

**readonly：一个只读的响应式对象。可以读取它，但不能修改它**

现实意义：维护**单向数据流 (Unidirectional Data Flow)**。例如，组件的 `props` 应该是只读的，防止子组件意外修改父组件的状态。
核心实现：Set 拦截不执行 `trigger`，并给出警告；Get 拦截也没有必要`track`去收集依赖

- **createGetter/ createSetter通过闭包参数返回Readonly的get和set函数**

```typescript
export function createGetter(isReadonly = false) {
    // target (Object): 原生对象 
    // key (String | Symbol): 属性名
    //  receiver (Object): 代理对象本身
    return function getter(target: any, key: string | symbol, receiver: any) {
        // const res = target[key] 对象有get属性并且里面有this的嵌套依赖问题
        // 保证每一个属性都会触发到代理的get保证收集成功依赖
        // const res = target[key]
        const res = Reflect.get(target, key, receiver)
        if (!isReadonly) track(target, key)
        return res
    }
}

export function createSetter(isReadonly = false) {
    return function set(target: any, key: string | symbol, newValue: any, receiver: any) {
        // 直接返回警告，同时不允许修改
        if (isReadonly) {
            console.warn(
                `Set operation on key "${String(key)}" failed: target is readonly.`,
                target
            );
            return true
        }
        // target[key] = newValue
        const res = Reflect.set(target, key, newValue, receiver)
        trigger(target, key)
        return true
    }
}
```

- 新建一个**readonlyHandlers控制器**

```typescript
/**
 * 导出 mutableHandlers对象
 */
export const readonlyHandlers = {
    get: readonlyGet,
    set: readonlySet
};
```

- 整理一下reactive.ts文件代码

```typescript
export function reactive(raw: any) {
    return createActiveObject(raw, mutableHandlers)
}

export function readonly(raw: any) {
    return createActiveObject(raw, readonlyHandlers)
}

function createActiveObject(raw: any, baseHandlers: any) {
    return new Proxy(raw, baseHandlers);
}
```