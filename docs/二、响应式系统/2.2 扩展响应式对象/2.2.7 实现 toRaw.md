# 实现 toRaw

> 核心：转为原始值

它的作用是扒掉 `Proxy` 的外衣，拿到最里面的那个原始 JavaScript 对象。作用：

- **获取原始值时避免触发响应式的get拦截（依赖收集）**
- **不必要的自动拆包，**（Ref Unwrapping），导致我们拿到的是 `value` 而不是 `ref` 本身，从而误判。 见3.4节

实现：

- 定义暗号 (Flags)

```typescript
//src/reactivity/reactive.ts
export const enum ReactiveFlag {
    IS_REACTIVE = "__v_isReactive",
    IS_READONLY = "__v_isReadonly",
    RAW = "__v_raw" //新增
}
```

- 修改拦截器（对于Flags类型的key）**返回原始对象**

```typescript
export function createGetter(isReadonly = false, shallow = false) {
    return function getter(target: any, key: string | symbol, receiver: any) {
        // ... 
        
        // 判断是不是toRaw 返回原始对象
        else if (key === ReactiveFlags.RAW) {
            return target;
        }
        // ===========================================
				const res = Reflect.get(target, key, receiver)
		...
    }
}
```

- 实现 `toRaw` 函数 (外部接口): 注意最后需要递归防止proxy套proxy的情况

```typescript
export function toRaw(observed: any): void {
    /**
     * 普通对象 返回 underfind 
     * reactive proxy对象 返回target
     */
    const raw = observed && observed[ReactiveFlags.RAW];
    // 这里之所以要递归，可能出现readonly(reactive(obj))
    // 终的target一定是没有ReactiveFlags.RAW作为递归结束条件 
    return raw ? toRaw(raw) : observed
}
```