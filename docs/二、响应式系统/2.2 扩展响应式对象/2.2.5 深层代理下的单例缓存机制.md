# 2.2.5 实现 shallow功能（浅响应式）

在前面实现的 `readonly` 中，如果对象很深（例如 `{ a: { b: { c: 1 } } }`），当我们访问 `a` 时，系统会自动把 `a` 转为只读代理；访问 `b` 时，又把 `b` 转为只读代理……这就是**深层递归**。

有时候，我们其实只希望保护**最外层**的容器不被修改（比如组件的 `props` 对象本身的引用），但**不关心**（或者为了性能不想处理）内部属性的深层响应式转换，因此需要一种机制，能够**截断递归。就是**shallowReadonly

- 改造 Getter 工厂 (The Logic)： 还是通过闭包参数的形式加入一个新的参数

```typescript
export function createGetter(isReadonly = false, shallow = false) {
    // target (Object): 原生对象 
    // key (String | Symbol): 属性名
    //  receiver (Object): 代理对象本身
    return function getter(target: any, key: string | symbol, receiver: any) {
				...
        if (!isReadonly) track(target, key)

        //shallow 直接返回
        if (shallow) return res

        // 根据返回值res判断，如果res是对象，需要再根据这个对象建立响应式
        // 最后要不要返回响应式对象，或者需不需要将obj = {a: { b : 1}}
        // 改为obj.a的指针改为proxy对象
        if (isObject(res)) {
            return isReadonly ? readonly(res) : reactive(res)
        }
        return res
    }
}
```

- 组装一个新的 Handlers (The Configuration)

```typescript
const shallowReadonlyGet = createGetter(true, true)
/**
 * 导出 shallowReadonlyHandlers对象，直接使用extend进行复用
 */
export const shallowReadonlyHandlers = extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
})
```

- 对外暴露 API (The Interface)

```typescript
export const shallowReadonlyMap = new WeakMap();
export function shallowReadonly(raw: any) {
    return createActiveObject(raw, shallowReadonlyHandlers, shallowReadonlyMap);
}
```