# 2.2.3 实现 isReactive 和 isReadonly和isProxy

目前的其实是存在问题，`Proxy` 有一个“缺点”：**它是透明的**。无法通过标准的 JS API（比如 `obj instanceof Proxy`）来判断一个对象到底是不是 Proxy，或者它是被 `reactive` 包裹的还是被 `readonly` 包裹的。因此**就需要自己设计Flags机制**

其实核心还是利用Getter的拦截，通过自定义对象的key来进行拦截返回对应的数据类型

- 定义 Flags 枚举 (Engineering)

```typescript
//packages/reactivity/src/reactive.ts
export const enum ReactiveFlag {
    IS_REACTIVE = "__v_isReactive",
    IS_READONLY = "__v_isReadonly"
}
```

- 改造 `createGetter`，加入Flags的逻辑

```typescript
//packages/reactivity/src/baseHandlers.ts
export function createGetter(isReadonly = false) {
    // target (Object): 原生对象 
    // key (String | Symbol): 属性名
    //  receiver (Object): 代理对象本身
    return function getter(target: any, key: string | symbol, receiver: any) {
        // 拦截Flags的读取
        // 判断是不是Reactive proxy对象
        if (key === ReactiveFlag.IS_REACTIVE) {
            return !isReadonly //取反就好了
        }
        // 判断是不是Readonly proxy对象
        if (key === ReactiveFlag.IS_READONLY) {
            return isReadonly
        }
				// .... 一致
    }
}
```

- 实现对外工具函数

```typescript
/** packages/reactivity/src/reactive.ts
 * // 1. 尝试读取特殊属性
 * @param value 
 * 2. 如果 value 是 Proxy，触发 get 拦截，返回 true
 * 3. 如果 value 是普通对象，返回 undefined
 * 4. 使用 !! 将 undefined 强转为 boolean (false)
 */
export function isReactive(value: any) {
    return !!value[ReactiveFlag.IS_REACTIVE]
}

export function isReadonly(value: any) {
    return !!value[ReactiveFlag.IS_READONLY]
}

/**
 * 判断isProxy，其实就是isReactive或者isReadonly返回true就可以
 * @param value 
 */
export function isProxy(value: any) {
    return isReactive(value) || isReadonly(value)
}
```