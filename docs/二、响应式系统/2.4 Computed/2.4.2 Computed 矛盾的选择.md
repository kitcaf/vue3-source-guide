# 2.4.2 Computed 矛盾的选择

存在的问题：虽然依赖变了，但计算结果没变，不应该触发副作用（**真实的是DOM操作**）

```typescript
const src = ref(0)
const c = computed(() => src.value % 2) // 结果只可能是 0 或 1
effect(() => console.log(c.value)) // 副作用

src.value = 2; // c 的结果还是 0，没变。此时应该就不应该触发依赖更新
```

很容易就想到**在scheduler进行初始值和新值的判断**

- 判有没有外层监听computed变量
- 如果没有：**重新计算（必须使用** `this._effct.run()` **），然后只要重新计算了就是**`this._dirty = false` 后面没有必要重新计算

```typescript
class ComputedRefImp {
    ...
   constructor(public fn: Function) {
				...
        this._effct = new ReactiveEffect(this.fn, () => {
            if (this.dep!.size === 0) { //没有外层监听computed变量
                this._dirty = true
                return
            }

            const newValue = this._effct.run();
            //既然上面都计算了，那就无论如何都get value()都不应该计算
            this._dirty = false;
            if (hasChanged(newValue, this._value)) {
                //未来避免get value再计算一遍，这里直接赋值
                this._value = newValue
                //同时派发外层的依赖
                triggerRefValue(this)
            }
        })
    }
   ...
}
```

注：**必须使用** `this._effct.run()` ，**看下面的分支切换例子**

```typescript
const flag = ref(true)
const a = ref(10)
const b = ref(20)

// 计算逻辑：如果 flag 是 true，就依赖 a；否则依赖 b。
const c = computed(() => {
    return flag.value ? a.value : b.value
})

effect(() => {
		return `{{c.value}}` //假设DOM更新
})
设置：flag.value = false ，如果使用this.fn()的情况
（1）scheduler执行 （2）const newValue = this.fn() （3）结果是20
（4）此时并没有将计算属性监听到b
未来b的变化，不会导致c的更新，导致失败
```

为什么说本节是**矛盾的**：因为它**牺牲了computed的懒执行**，如果你不读取它的值，它永远不会执行 getter（省性能）。现在的情况是只要computed监听的响应式变量变化了，那么computed自身的依赖更新就会导致重新计算