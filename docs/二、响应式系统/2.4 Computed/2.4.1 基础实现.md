# 基础实现

```typescript
const obj = reactive({ count: 1, text: "hello" });

function expensiveCalculation() {
    console.log("耗时计算正在运行...");
    return obj.count * 2; // 假设这里是很复杂的逻辑
}

effect(() => {     // 假设这是组件渲染函数
    console.log("渲染界面");
    // 哪怕我们修改的是 obj.text，导致组件重新渲染
    // 这个函数也会被重新调用！
    document.body.innerText = `${obj.text} - ${expensiveCalculation()}`;
});
```

在上面的情况其实我们就会将expensiveCalculation函数改为**Computed函数**

**Computed函数：本质是带缓存和响应式的函数**

$Computed = Function + Cache(\text{缓存}) + Reactivity(\text{响应式桥梁})$

它同时扮演了两个角色：

- **对上游（对于响应式数据）**：它是一个 **Effect（消费者），它所依赖的响应式变量变了，它可以快速更新值并通知；同时如果没有变，它可以快速根据缓存返回之前依赖的结果**
- **对下游（对于组件渲染）**：它是一个 **Dependency（数据源）**

实现需要包括三个核心性质：

- **懒执行 (Lazy)**：如果你不读取它的值，它永远不会执行 getter（省性能）
- **缓存 (Caching)**：如果依赖的数据没变，多次读取直接返回缓存值，不重复计算
- **响应式 (Reactive)**：依赖变了，它要能感知，并通知引用它的人

实现的过程把握一点：Computed(fn)，fn里面一定是会访问响应式变量，每次更新后一定是会**重新执行fn并且获取结果值**，其实和ref(value) effect(fn) 类似。

**实现：**

- 基础骨架：需要一个 `_dirty` 开关（脏值检测），默认是true - 需要计算的，计算完成后就置为false, 只有当依赖更新时需要立刻置为true，然后Computed只有get，没有set

```typescript
/**
 * ComputedRefImp类
 */
class ComputedRefImp {
    private _dirty: Boolean = true
    private _value: any //缓存结果
    //value 就是需要对getter函数结果值进行拦截

    constructor(public fn: Function) {
    }

    get value() {
        if (this._dirty) { //如果是dirty
            this._value = this.fn()
        }
        return this._value //否则返回缓存值
    }
}

export function computed(getter: Function) {
    return new ComputedRefImp(getter)
}
```

- **内层收集：内部响应式变量的依赖收集（**Computed 依赖 -> 源 Ref (如 `count`)**）**：computer感知getter中响应式变量变化以更新_dirty，其实就是将getter放入到effect()函数，收集依赖。

```typescript
const reactiveEffect = new ReactiveEffect(this.fn)
reactiveEffect.run() //收集依赖
// ...
```

- 如上代码：依赖更新的副作用函数是this.fn，this.fn是用户定义的，没有办法往里面插入this._dirty = false；?  不要忘记了。**1.6 scheduler 实现了**对trigger阶段一个拦截，**我们可以自己自定义逻辑**写入到**scheduler里面**

```typescript
const reactiveEffect = new ReactiveEffect(this.fn, () => {
    if (!this._dirty) this._dirty = true
})
reactiveEffect.run() //收集依赖
```

- **上面的代码放到哪里呢？**因为computed需要有**懒执行特性；new ReactiveEffect放在constructor中但不执行**reactiveEffect.run()，只有真正get value() 时才执行，**reactiveEffect.run( ) 将this._getter()代替就可以了- 既执行了收集依赖又执行this._getter()获得了返回值。同时依赖不会被重复收集（判重）**

```typescript
class ComputedRefImp {
    private _dirty: Boolean = true //开关
    private _value: any //缓存结果
    private _effct: ReactiveEffect //ReactiveEffect
    readonly __v_isRef = true //让proxyRefs识别，避免模板中写.value

    constructor(public fn: Function) {
        this._getter = getter
        //ReactiveEffect将this._getter载入到this._effct.run()里面了
        this._effct = new ReactiveEffect(this.fn, () => {
            if (!this._dirty) this._dirty = true
        })
    }

    get value() {
        if (this._dirty) { //如果是dirty
            this._value = this._effct.run()
        }
        return this._value //否则返回缓存值
    }
}
```

**注：Computed 就是一种 Ref，在template中也不用写.vlaue，因此回包在proxyRefs里。需要加入**`readonly __v_isRef = true`

- **外层收集（组件/Effect 依赖 -> Computed）**：Computed 也会被监听依赖，因此需要触发依赖Computed的副作用更新。其实就是参考ref的做法，直接调用trackRefValue(this) 和 triggerRefValue(this)

**目前存在的问题：**

```typescript
const value = reactive({ foo: 1 });
const cValue = computed(() => value.foo);
effect(() => {
    dummy = cValue.value;
});
//修改底层数据 -> computed 变脏 -> 触发外层 effect 核心：computed本身也是响应式变量
value.foo = 2; //期待：dummy也被正确更新了变为2
```

```typescript
class ComputedRefImp {
		...
    readonly dep?: Set<ReactiveEffect>; //【新增】

    constructor(public fn: Function)  {
        this.dep = new Set<ReactiveEffect>()

        this._getter = getter
        this._effct = new ReactiveEffect(this.fn, () => {
            if (!this._dirty) this._dirty = true

            //同时相应外层的依赖
            triggerRefValue(this) //【新增】
        })
    }

    get value() {
        trackRefValue(this) //【新增】 // 让effect(() => computed变量) 收集这个依赖
        if (this._dirty) { //如果是dirty
            this._value = this._effct.run()
            this._dirty = false
        }
        return this._value //否则返回缓存值
    }
}
...
```