# 3.1 实现 ref 功能

目前的 `reactive` 是基于 ES6 的 `Proxy` 实现的，有一个很明显的问题：`Proxy` 的限制：它只能代理 **对象 (Object)**，无法代理 **基本类型** (String, Number, Boolean)，`new Proxy(1, handler)` 会直接报错

解决方法：**既然基本类型不能被拦截，那我们就给它穿上一层对象的“外衣”，这也是为什么ref要加入一个.value的原因；利用类的 Getter/Setter 拦截器来实现对基本类型的包裹**

**实现：**

- 新建一个packages/reactivity/src/ref.ts文件，并且新建`RefImpl` 类。注意实际的实现的话，不用把基础类型变量真的转换为对象然后进入reactite中，因为你想基础类型变量如果转换为对象，其实它的key永远都是**该基础类型变量，也就是说targetMap下的depsMap永远只有一个pair对就是<该基础类型变量, dep>。其实整过程性能是浪费的。**

**这也是为什么使用通过class的get、set属性成员的方式完成依赖的收集和更新（本质也是proxy）**

 （1）ES6 类的 **访问器属性（**ES5 时代的 `Object.defineProperty`**）专职安检员 — 拦截某个属性**

（2）Proxy **全能安检员 -** 拦截对这个对象 **所有** 属性的操作（增删改查）

```typescript
import { hasChanged } from "@mini-vue/shared";
import { ReactiveEffect, trackEffects, triggerEffects } from "./effect";

//packages/reactivity/src/ref.ts
class RefImpl {
    private _value: any;
    public dep?: Set<ReactiveEffect>;

    constructor(value: any) {
        this._value = value
        this.dep = new Set<ReactiveEffect>()
    }

    get value() {
        //收集依赖，不需要全局 targetMap 查找，直接收集到 this.dep
        trackRefValue(this)
        return this._value
    }

    set value(newValue) {
        // 先看看值变了没，变了才触发
        if (hasChanged(newValue, this._value)) {
            this._value = newValue
            triggerRefValue(this)
        }
    }
}

function trackRefValue(ref: RefImpl) {
    trackEffects(ref.dep!)
}

function triggerRefValue(ref: RefImpl) {
    triggerEffects(ref.dep!);
}
```

- 为了应对`const r = ref({ count: 1 })`这种情况。虽然 `ref` 包裹了对象，但当我们访问 `r.value.count` 时，如果不做处理，`r.value` 就是一个普通对象。回到了上步我们讨论的问题：**`ref` 的值如果是对象，内部应该自动把这个对象转为 `reactive`**

**注意：（1）不要遗漏了修改时修改为对象（2）_rawValue的问题**

```typescript
class RefImpl {
    private _value: any;
    /**
     * _rawValue保留最原始的数据；Proxy 对象不等于被代理的原生对象
     * 如果返回的Proxy 对象，那么rawValue就是被代理的原生对象
     * 如果不怎么写？
     * const obj = { foo: 1 };
     * const r = ref(obj);
     * r.value = obj; //重新赋值同一个对象，但是set不认为是同一个对象
     * Proxy 对象不等于被代理的原生对象不相同，导致组件重新渲染
     */
    private _rawValue: any;
    public dep?: Set<ReactiveEffect>;

    constructor(value: any) {
        this._rawValue = value

        //直接改引用，get value直接就是指向响应式对象
        this._value = convert(value)
        this.dep = new Set<ReactiveEffect>()
    }

    get value() {
        //收集依赖，不需要全局 targetMap 查找，直接收集到 this.dep
        trackRefValue(this)
        return this._value
    }

    set value(newValue) {
        // 先看看值变了没，变了才触发
        if (hasChanged(newValue, this._rawValue)) {
            this._rawValue = newValue
            this._value = convert(newValue)
            triggerRefValue(this)
        }
    }
}

export function ref(value) {
    return new RefImpl(value);
}
```