# 实现 toRef & toRefs

目前存在问题：（1）响应式对象解构时**导致响应式丢失（引用对象类型不会**）（2）想重新创建一个变量a引用响应式对象中的基础类型变量，导致变量a的响应式无效

```typescript
const state = reactive({
    foo: 1,
    bar: {
	    a:1
    }
});
const { foo, bar } = state; //此时的 foo 只是一个普通的数字1，此时foo失去响应式了
```

解构就是**变量的重新赋值（copy）**；创新了一个新的变量foo = state.foo（proxy本质还是对象只是拦截了对象的操作）。因此foo = 1，后面使用foo变量时失去了响应式

所以在解构的过程中只有**基本类型才会实现响应式，**我们知道基础类型加入响应式的操作就是ref。因此在解构的问题解决上：**核心代理ref - 中间人转发（**reactive已经对变量有响应式，没有必要再对新的变量进行响应式创建**）**

## （1）实现 toRef

> 对响应式对象中的某个特定的key进行代理，最后还是要.value
> 
- 定义一个 `ObjectRefImpl` 类，get和set代理原对象中的key

```typescript
class ObjectRefImpl {
    public __v_isRef = true; // ref标志

    constructor(
        public _object: any,
        public _key: any,
    ) { }

    get value() {
        return this._object[this._key]
    }

    set value(newValue: any) {
        this._object[this._key] = newValue;
    }
}

export function toRef(object: any, key: string) {
    return new ObjectRefImpl(object, key)
}
```

目前这段代码是存在问题的：假设`this._key`对应的是ref,  如下代码：

```typescript
state = reactive({a: ref(1)}) //reactive对象
a = toRef(state, 'a') // a的调用是a.value.value, 太复杂了
state = {a: ref(1)} //普通对象
a = toRef(state, 'a') //还是调用a.value.value 
```

- 问题一（**支持reactive对象解构**）：需要在回去`baseHandlers.ts` 打补丁，对get和set 加入ref的解包（unwarpper)

```typescript
export function createGetter(isReadonly = false, shallow = false) {
    return function getter(target: any, key: string | symbol, receiver: any) {
				...
        //shallow 直接返回
        if (shallow) return res
        
        // ref对象的直接解包
        if (isRef(res)) {
            return res.value
        }
				...
    }
}

export function createSetter(isReadonly = false) {
    return function set(target: any, key: string | symbol, newValue: any, receiver: any) {
				...
        //Ref 自动赋值
        const oldValue = (target as any)[key];
        if (isRef(oldValue) && !isRef(newValue)) {
            oldValue.value = newValue;
            return true;
        }
					
        // target[key] = newValue
        const res = Reflect.set(target, key, newValue, receiver)
				...
    }
}
```

**注：**shallowR**eactive** 或者 shallowReadonly 在这里被认为**是普通对象**，因此ref对象的直接解包在shallow判断之后（**源码的顺序**），其实我认为放在之前的话更好，这样后面的**普通对象解构的处理判断就不需要考虑shallow(源码是在ObjectRefImp加入对shallow和原型链的判断 — 我们就不加了我们就加入对普通对象解构的处理即可)，因为shallow更考虑可以拿到完整的控制权**

```typescript
const r1 = ref(1)
const r2 = ref(2)

// 我想要一个对象，里面就存着这两个 Ref 引用
const container = shallowReactive({ r1, r2 })

// Vue 的设计允许我这样做：
console.log(container.r1) // 拿到的是 Ref 对象本身 
console.log(container.r1.value) // 我可以手动控制何时取值
```

- 问题二（**支持普通对象解构**）：这里就是使用toRaw 避免触发 Proxy 的 get (避免不必要的 track)

```typescript
class ObjectRefImpl {
    public __v_isRef = true; // ref标志

    get value() {
        /**
         * 兼容普通对象
         * 如果 _object 是 reactive，它getter里自动解包了，unRef(值) 还是 值
         * 如果 _object 是普通对象，它getter返回 Ref，unRef(Ref) 变成 值。
         */
        const val = this._object[this._key]
        return unRef(val)
    }

    set value(newValue: any) {
        /**
         * 兼容普通对象 setter 
         * 普通对象没有 Proxy 帮我们拦截 setter
         * 必须手动判断：如果原值是 Ref，我们要更新 Ref.value
         */
        const raw = toRaw(this._object)
        const val = raw[this._key]

        //普通对象和reactive中的ref变量 直接处理
        if (isRef(val) && !isRef(newValue)) {
            val.value = newValue
        } else {
            //普通对象和reactive中的普通变量；既有响应式又有正常变量的修改
            this._object[this._key] = newValue
        }
    }
}
```

## （2）实现 toRefs

> 对整个响应式对象中的属性都进行解构并保持响应式
> 

逻辑非常简单：遍历源数据的所有key, 对每一个key调用我们上一节写好的toRef

```typescript
export function toRefs(object: any) {
    const ret: any = Array.isArray(object) ? new Array(object.length) : {}
    for (const key in object) {
        ret[key] = toRef(object, key)
    }
    return ret
}
```