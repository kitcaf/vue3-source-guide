# 实现 proxyR

- 目前的设计每一个ref变量都要加 `.value` ，这样是不方便的，在写`template` 的时候容易漏写
- 防止 Ref 被意外杀掉(Setter 保护)

未来这里会**通过proxyR包装`<script>`的对象，我们现在vue文件中的`<script>`ref对象是要.value。其实**Vue 3 曾经尝试推行过一个实验性语法糖叫 **Reactivity Transform (响应式语法糖)，**也就是 `let count = $ref(0)` （通过编译阶段 `$替换为.vlaue)`。不过好像最后社区是反对的
> 

**实现：**

- `get` 就直接unRef返回；`set` 注意防止 `Ref` 被意外杀掉

```typescript
/**
 * proxyRefs代理某个对象，可以将ref属性值unref
 * @param objectWithRefs 是一个对象：对象里面可能有ref对象属性
 */
export function proxyRefs(objectWithRefs: any) {
    return new Proxy(objectWithRefs, {
        get(target, key, receiver) {
            return unRef(Reflect.get(target, key, receiver))
        },

        // 也是要处理一下set，ref时将value加上
        set(target, key, newValue, receiver) {
            const oldValue = target[key]
            /**
             * 解决修改值不加value的修改：（防止 Ref 被意外杀掉）
             * 如果原来的值是 Ref，且新来的值【不是】Ref
             * 其实意味这用户想修改Ref的.value，而不是想替换掉整个Ref
             */
            if (isRef(oldValue) && !isRef(newValue)) {
                oldValue.value = newValue;
                return true;
            }
            return Reflect.set(target, key, newValue, receiver)
        },
    })
}
```

**如果还是不理解可以看如下的测试**：

```typescript
const user = { // 到了编译章节，user对象其实就是组件对象中的数据对象属性
     age: ref(10),
     name: "xiaohong"
};
const proxyUser = proxyRefs(user);
proxyUser.age = 20; //不用写age.value了
expect(proxyUser.age).toBe(20); //成功修改
// 修改ref属性（防止 Ref 被意外杀掉）
proxyUser.age = 10 // 这个时候其实用户想的是修改ref中的.value，只是没有写
expect(proxyUser.age).toBe(10)
```