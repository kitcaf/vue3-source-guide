# 3.3.2 实现组件 props 功能

> **组件 Props** 是父组件传递给子组件的数据，子组件可以通过 `setup(props)` 的参数访问，或者在 `render` 中通过 `this.name` 访问
> 

在当前的runtime-time阶段指的是：**h函数的第二个参数**（由compllier阶段生成），

```typescript
h(ChildComponent, { name: "minivue", age: 3 })
```

## 基础实现

> Props 通常是 **浅层响应式** 且 **只读** 的（**本节我们先实现最基础的数据挂载**）
> 
- 新建 `componentProps.ts` ，专门处理 Props 的初始化逻辑

```typescript
// packages\runtime-core\src\componentProps.ts
import { ComponentInternalInstance } from "./component";

/**
 * 初始化组件props
 */
export function initProps(instance: ComponentInternalInstance, rawProps: any) {
    instance.props = rawProps || {}
}
```

- 修改 **组件 Proxy** 拦截逻辑，支持props的查询

```typescript
// packages\runtime-core\src\componentPublicInstance.ts
import { hasOwn } from "@mini-vue/shared";
export const PublicInstanceProxyHandlers = {
    // 解构动作：取出 target._ 赋值给 instance 变量（ES6解构+重命名）
    get({ _: instance }: { _: ComponentInternalInstance }, key: string) {
        const { setupState, props } = instance;

        // 检测setupState 改为hasOwn-不查原型链
        if (hasOwn(setupState, key)) {
            return setupState[key]
        }
        // 查props，虽然也可以直接if, 但是还是表达互斥关系好一点
        else if (hasOwn(props, key)) {
            return props[key]
        }

        // $ 开头的公共属性
        const publicProperty = publicPropertiesMap[key]
        if (publicProperty) {
            return publicProperty(instance)
        }
    }
}
```

- 修改组件初始化流程

```typescript
//\packages\runtime-core\src\component.ts
export function setupComponent(instance: ComponentInternalInstance) {
    // 执行setup
    setupStatefulComponent(instance)
    //处理props
    initProps(instance, instance.vnode.props)
}
export function setupStatefulComponent(instance: ComponentInternalInstance) {
    const Component = instance.type;
    const { setup } = Component

    if (setup) {
		    // setup传入props
        const setupResult = setup(instance.props)
        handleSetupResult(instance, setupResult)
    } else {
        finishComponentSetup(instance)
    }
}
```

## 优化：浅层响应式只读

我想大家一个听过父子组件之间的**单向数据流**：如果父组件的数据变了，传递给子组件的 `props` 也会变，并且子组件里使用 `props` 的地方也会发生变化，目前肯定是没有实现的

但是我想先对关于**为什么子组件会更新？为问题引出props浅层响应式的重要性**

```typescript
// 子组件A
<template>
  <div>{{ props.count }}</div>
</template>
// 子组件A complier编译的render结果
const A {
	funciton setup() {}
	function render(_ctx, _cache) { // 我们目前都知道render会包裹在effect函数中做依赖更新
	  return h("div", null, _ctx.props.count); 
	}
}
```

我们过一遍更新流程：

- 父组件props出现更新，导致父组件的 Render 跑了一遍
- patch更新阶段：子组件没有变（只是属性变了），**复用**子组件实例（**不会重新执行组件的创建的整个生命周期**）
- patch更新阶段：**Update Props** 内部执行 `instance.props.count = 新值` 。此时你告诉我`instance.props`**必须是什么？**必须是响应式变量，只有是响应式变量才会导致A.render函数重新执行，界面更新

**注：**不要混淆**组件实例的创建(Setup/Construction，执行setup方法、数据的装配等等)和组件的渲染(Rendering)**

### 实现

其实就很简单了：**核心就是将props设置为响应式变量（只读浅层响应式变量）**，这是第二阶段(响应式系统 Reactivity)和第三阶段(运行时 Runtime-Core)的第一次接触

- 修改 `componentProps.ts` ，加入**shallowReadonly**

```typescript
import { shallowReadonly } from "@mini-vue/reactivity";
import { ComponentInternalInstance } from "./component";

const EMPTY_OBJ = Object.freeze({});

export function initProps(instance: ComponentInternalInstance, rawProps: any) {
	  // 核心就是： shallowReadonly代码就结束了
    instance.props = rawProps ? shallowReadonly(rawProps) : EMPTY_OBJ
}
```