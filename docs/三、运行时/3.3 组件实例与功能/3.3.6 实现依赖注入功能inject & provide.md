# 3.3.6 实现依赖注入功能 provide/inject

> **Provide/Inject** 是提供的一种跨层级组件通信方式
> 

**Provide (提供)**：在祖先组件中定义数据，其后代组件可以获取数据。**Inject (注入)**：在任何后代组件中（无论有多深）获取数据。

实现原理：**原型链继承**、**实例属性挂载**以及**递归查找**

**注：**因为Provide提供的是**所在组件的后代**的数据，因此不能说直接在**原型上构建一个全局数据**，而是维护一个**关系链树（通过原型链的查找规律）**

前提知识：查找某个对象时，先查找对象本身是否存在该属性，**如果不存在**，去对象的原型查找，如果还是不存在，再去对象的原型的原型中查找。**直到成功查找或者不存在查找区域了**

由于它还是比较绕的，因此这里我们对实现进行更细致的讲解：

实现的核心是**对组件实例构建了两个新的属性**： **`parent` 、`provides`**

- **`parent`：**是**物理上的父子关系，它就是指向自己的父组件。**它只指向它的父组件
- **`provides`：存储provide的数据，通过原型链间接连接了所有祖先的 provides 对象**

例子：假设**组件树结构**：`App` (根) -> A -> B -> C -> D

如果任何组件的setup中都不调用 `provide` 函数：

（1）App 初始化，`App.provides` = `{}`  (内存地址：0x01)

（2）向下递归：A.provides = **parent(App)**.provides, B.provides = **parent**.provides … A, B, C, D的组件都指向App.provides（内存地址：0x01)

如果在A和C中的setup调用`provide`函数：

（1）App 初始化，`App.provides` = `{}`

（2）A的setup中执行了provide('key', 'hello')，**导致A.`provides` 创建一个新的对象并且将instance.parent.`provides` 构建为该对象的原型**。也就此时A.`provides` 为

```tsx
A.provides = {'key' : 'hello', prototype（原型）: {}}
```

（3）B的setup没有调用`provide`函数，B.`provides` = **parent.**provides 为：

```tsx
B.provides = {'key' : 'hello', prototype: {}}
```

（4）C的setup中执行了provide('value', 'minvue')，导致C.`provides` **创建一个新的对象并且将instance.parent.`provides` 构建为该对象的原型**。也就此时C.`provides` 为

```tsx
C.provides = { 
	'value': 'minvue'
	prototype: {'key' : 'hello', 
		prototype: {}
	}
}
```

（5）D的setup没有调用`provide`函数，D.`provides` = **parent.**provides 为：

```tsx
D.provides = { 
	'value': 'minvue'
	prototype: {'key' : 'hello', 
		prototype: {}
	}
}
```

如果在D中执行inject(’value’) ，它找到的是C组件provide的结果。如果D中执行inject(’key’)它找到的是A组件provide的结果。（**原型链搜索**）**D.`provides` 通过原型链浓缩所有父组件的provides的对象（并且保证了搜索顺序，离的近provides优先查找）**

## 基础实现

- 第一步：修改 `createComponentInstance` ， 新增两个属性并初始化

```tsx
//
export function createComponentInstance(
    vnode: VNode,
    parent: ComponentInternalInstance): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
        vnode,
        type: vnode.type as ComponentOptions,
        setupState: {},
        proxy: {},
        props: null,
        slots: {},
        parent: parent, // 新增
        // 初始化App组件（根组件）的parent一定是null, 需要初始化为{} (Object.create(null))
        // 其他组件都是parent.privides
        provides: parent ? parent.privides : Object.create(null),
        render: null,
        emit: () => { },
    }
    ...
}
```

- 第二步：传递 `parent` (在 Renderer 中) ，因为 `createComponentInstance` 现在需要 `parent` 参数，我们需要在渲染器里把这个参数传下去。

```tsx
// packages\runtime-core\src\renderer.t
function patch(
    n1: VNode | null,
    n2: VNode,
    container: HostElement,
    parent: ComponentInternalInstance | null = null) { // 【新增】增加一个参数
		... 
        default:
            // 处理组件vNode
            if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
                processComponent(n1, n2, container, parent) //【新增】 输入参数
            }
						...
    }
}

function processComponent(
    n1: VNode | null,
    n2: VNode,
    container: HostElement,
    parent: ComponentInternalInstance | null //【新增】
) {
    // 表示挂载
    if (!n1) mountComponent(n2, container, parent) //【新增参数】
}

function mountComponent(
    initialVNode: VNode,
    container: HostElement,
    parent: ComponentInternalInstance | null //【新增参数】
) {
		//【新增参数】输入
    const instance = createComponentInstance(initialVNode, parent)
		...
}

function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {
    const { proxy } = instance
    const subTreeVNode = instance.render!.call(proxy, proxy)
    // 继续递归【新增】将当前实例作为parent
    patch(null, subTreeVNode, container, instance)
    initialVNode.el = subTreeVNode.el
    }

```

- 第三步：实现 `provide` 和 `inject`

**实现 `provide` (存)，主要是新建对象并且它的原型成功赋值为parent.provides**

注：加入**if (provides === parentProvides) { 因为可能存在一个组件中的setup写了多次provide，没有必要每次都创建新的对象，是同一个组件，直接在对应的对象中加入新的属性就可以，然后就是注意执行的顺序（新旧的provides）**

```tsx
//packages\runtime-core\src\apiInject.ts
export function provide(key: string, val: Object) {
    // 因为provide是在setup中执行的，可以通过全局获取组件实例
    const currentInstance: ComponentInternalInstance = getCurrentInstance()

    if (currentInstance) {
        // 第一次的时候它是一切父组件累计的一个对象
        let { provides } = currentInstance
        // 多次provide只执行一次
        if (provides === currentInstance.parent?.provides) {
            currentInstance.provides = Object.create(provides)
        }
        // 这里一定要写currentInstance.provides，不能写provides
        // 除非在if (provides === currentInstance.parent?.provides) { 重新赋值
        // 因为目前的provides有可能是不等于currentInstance.provides（组件的第一次provide）
        currentInstance.provides[key] = val
    }
}
```

**实现 inject (取)**

**注：避免自己注入了自己提供的数据，所以查找的instance.parent.provides**

```tsx
//packages\runtime-core\src\apiInject.ts
export function inject(key: string, defaultVal: any) {
    const currentInstance: ComponentInternalInstance = getCurrentInstance()

    if (currentInstance) {
        const parentProvides = currentInstance.parent?.provides!
        // for in是会查原型链的，同时有一个判断是否存在
        if (parentProvides && key in parentProvides) {
            return parentProvides[key]
        }
        else if (defaultVal !== undefined) {
            return typeof defaultVal === "function" ? defaultVal() : defaultVal;
        }
    }
}
```