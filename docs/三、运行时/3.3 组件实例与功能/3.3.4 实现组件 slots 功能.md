# 3.3.4 实现组件 slots 功能

> 如果说 `Props` 是父组件向子组件传递**数据**，那么 `Slots` 就是父组件向子组件传递**一段模板（HTML 或 VNode）**
> 

在进入插槽slots之前，必须了解complier阶段对template中的插槽的编译结果：在 Vue 3 规范中，**只有当 `children` 是一个对象（并且是函数对象形式）时，才认为它是插槽**

```tsx
//App父组件
<div> 
	<Child v-slot="slotProps"> 
	  <template #default>
	    <p>{{ slotProps.item }}</p>
	  </template>
	  <template #footer>
	    <span>bye</span>
	    <span>hei</span>
	  </template>
	</Child>
</div>

// complier 后的渲染函数结果如下：
h('div', null, [h(Child, null, {
  // 所有的插槽都被编译成了函数！
  default: (props) => [h("p", null, props.item)], // 作用域插槽
  footer: () => [h("span", null, "bye"), h("span", null, "hei")], // 普通插槽
  // 这里的 _ 是一个内部标识符，用来标识插槽的类型（是否稳定等）
  _: 1 
})])
```

注：即使没有显式写 `<template #default>`，只要它是组件的子元素，编译器就会自动包装成一个名为 `default` 的函数对象

`h` 函数（即 `createVNode`）的第三个参数 `children` 的类型**决定如何处理组件**，目前是存在两种类型

- **如果 `children` 是数组 `[...]`**： 认为这是**普通子节点**。它会直接遍历并渲染（已实现）
- **如果 `children` 是对象 `{}`**： 认为这是**插槽模式**。它不会直接渲染，而是把这个对象交给子组件实例的 `instance.slots`，由子组件决定什么时候去“调用”这些函数。

插槽 `children` 必须是函数对象，作用：（1）**延迟执行**，因为传的是函数，只有子组件决定渲染，vNode才会真正生成（2）**作用域插槽**，只有是函数，子组件才能传参，才可以实现作用域插槽（3）**精准更新**，如果插槽内容变了，其实只需要更新子组件就好了

## 基础实现

- 修改 ShapeFlags，加入一个新的ShapeFlags，并修改 createVNode自动赋值ShapeFlages

```tsx
// packages\shared\src\shapeFlags.ts
export const enum ShapeFlags {
    //001 HTML 元素
    ELEMENT = 1,
    //010(左移一位) 有状态组件 (平时写的普通组件)
    STATEFUL_COMPONENT = 1 << 1,
    //0100 子节点是纯文本（vnode.children）- 递归树等的判断
    TEXT_CHILDREN = 1 << 2,
    //01000 子节点是数组
    ARRAY_CHILDREN = 1 << 3,
    // 插槽子节点标志【新增】
    SLOTS_CHILDREN = 1 << 4
}
//\packages\runtime-core\src\vnode.ts
export function createVNode(
    type: vNodeType,
    props?: any,
    children?: string | any[] | null
): VNode {
    const vnode: VNode = {
        type,
        props,
        children: children ?? null,
        shapeFlag: getShapeFlag(type),
        el: null
    }

    // 叠加状态
    if (typeof children === "string") {
        vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN
    } else if (Array.isArray(children)) {
        vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN
    }

    // 判断slots
    if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
        if (typeof vnode.children === 'object') {
            vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN
        }
    }
    return vnode
}
```

- 实现 initSlots，把对应的**父组件渲染函数中的**slots部分的children 对象处理一下，挂载到对应的**子组件的** `instance.slots`

主要是要保证`instance.slots` 它的值函数都是返回数组：(string) ⇒ vnode[]这种格式，**插槽的多根节点可以由Fragment 处理**

```tsx
//packages\runtime-core\src\componentSlots.ts
/**
 * 将父组件渲染函数中的slots部分的children挂载到对应的子组件实例slots
 * @param instance 
 * @param children 
 */
export function initSlots(
    instance: ComponentInternalInstance,
    children: Record<string, Slot>) {
    const { slots, vnode } = instance

    if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
        normalizeObjectSlots(children, slots)
    }
}

function normalizeObjectSlots(
    children: Record<string, Slot>,
    slots: Record<string, Slot>) {
    for (const key in children) {
        const value = children[key]
        // 保证一定是slots[key] 执行的返回结果一定VNode[]
        // 因为用户可能手写render函数（不使用complier）直接返回一个 h() 得到的对象，而不是数组
        slots[key] = (props: any) => normalizeSlotValue(value(props));
    }
}

function normalizeSlotValue(value: VNode[] | VNode) {
    return Array.isArray(value) ? value : [value]
}
```

- 在相应的位置调用

```tsx
// packages\runtime-core\src\component.ts
export function setupComponent(instance: ComponentInternalInstance) {
    //处理props
    initProps(instance, instance.vnode.props)
    //处理slots
    initSlots(instance, instance.vnode.children as Record<string, Slot>)
    // 执行setup - 记得传入props参数
    setupStatefulComponent(instance)
}
```

- 实现 renderSlot 和 代理 $slots

给用户使用的 Helper 函数，**对应的子组件render对slot标签的渲染问题**，比如：

```tsx
<div class="child">
  <slot :age="18"></slot> :age就是作用域插槽输入到父组件的数据，其实本质还是子组件将参数传递就可以
</div>
// 子组件的 render 函数
function render(_ctx) {
  return h("div", { class: "child" }, [
      // 这里的参数直接对应 renderSlot 的定义！
      renderSlot( // 就是执行 instance.slots[name](props)
          _ctx.$slots,  // 参数 1: slots
          "default",    // 参数 2: name           
          { age: 18 }   // 参数 3: props
      )
  ])
}
```

**renderSlot去执行instance.slots[name](props)**，**同时_ctx配置组件代理找到对应的slots**

实现代码：

```tsx
//packages\runtime-core\src\componentSlots.ts
export function renderSlot(
    slots: Record<string, Slot>,
    name: string,
    props: any) {
    const slot = slots[name]
    if (slot) {
        // 创建Fragement包裹slot节点
        return createVNode(Fragment, {}, slot(props))
    }
}
//packages\runtime-core\src\componentPublicInstance.ts
const publicPropertiesMap: Record<string, (i: ComponentInternalInstance) => any> = {
    // （$el一般是在生命中期中访问（_ctx/this.$el），template不会使用）
    // 当用户访问 this.$el 时，返回 instance.vnode.el
    $el: (i: ComponentInternalInstance) => i.vnode.el,
    // @emit 当用户访问 _ctx/this.$emit 时, 返回另一个函数
    $emit: (i: ComponentInternalInstance) => i.emit,
    // $slots [新增]
    $slots: (i: ComponentInternalInstance) => i.slots
}
```