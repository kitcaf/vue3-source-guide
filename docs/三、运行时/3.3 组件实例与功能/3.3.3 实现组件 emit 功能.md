# 3.3.3 实现组件 emit 功能

> `emit`（发送事件）是组件间通信的**核心机制之一，** 它实现了从下往上的数据流向，与 `props`（从上往下）相辅相成
> 

`emit` 是一个函数，允许组件触发自定义事件。当事件触发时，父组件中通过 `on`（即 `@`）绑定的回调函数会被执行。

核心实现逻辑：**执行emit时，在组件的props查找是否存在对应的邦定事件即可**

## 基础实现

- 准备字符串处理工具，因为需要`emit('change-page')`映射到 `props['onChangePage']` 的事件名转换

```typescript
// \packages\shared\src\index.t
// foo-bar -> fooBar
export const camelize = (str: string) => {
    return str.replace(/-(\w)/g, (_, c: string) => {
        return c ? c.toUpperCase() : "";
    });
};

// foo -> Foo
const capitalize = (str: string) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
};

// foo -> onFoo
export const toHandlerKey = (str: string) => {
    return str ? "on" + capitalize(str) : "";
};
```

- **实现 emit 逻辑**

```typescript
// packages\runtime-core\src\componentEmit.ts
export function emit(
    instance: ComponentInternalInstance,
    event: string,
    ...args: any) {
    const { props } = instance
    //处理事件名: add-foo -> addFoo -> onAddFoo
    const handlerName = toHandlerKey(capitalize(camelize(event)))

    const handler = props[handlerName]
    if (handler) {
        handler(...args)
    }
}
```

- 挂载到组件实例

```typescript
// packages\runtime-core\src\component.ts
export function createComponentInstance(vnode: VNode): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
        vnode,
        type: vnode.type as ComponentOptions,
        setupState: {},
        proxy: {},
        props: null,
        render: null,
        emit: () => { }, // 先占位
    }
    instance.proxy = new Proxy({ _: instance }, PublicInstanceProxyHandlers)
    //将 emit 函数绑定到当前 instance 上, 只要调用instance.emit()
    // 通过bind此时它的第一个参数默认就是instance
    // 不需要自己处理emit(instance, event, ...) 这样调用
    // 直接就是emit(event)调用
    instance.emit = emit.bind(null, instance)
    return instance
}
```

我们回忆一下我们emit的使用，我们应该怎么将instance.emit注入到对应的**用户常用的使用方式中，主要存在下面的两种使用方式**

## setup中的emit

最常见的使用方式，可以看到本质上是通过向setup注入第二个参数

```typescript
// 语法糖-最后也是转换为下面的一种方式
<script setup>
const emit = defineEmits(['change']);
emit('change');
</script>

// 或者这种写法
export default {
  setup(props, { emit }) {
    // 这里的 emit 是 Vue 调用 setup 时传进来的第二个参数的一个属性
    emit('change'); 
  }
}
```

因此继续实现修改**`setupStatefulComponent`**

```typescript
//packages\runtime-core\src\component.ts
export function setupStatefulComponent(instance: ComponentInternalInstance) {
    const Component = instance.type;
    const { setup } = Component

    if (setup) {
        const setupResult = setup(instance.props, {
            emit: instance.emit
        })
        handleSetupResult(instance, setupResult)
    } else {
        finishComponentSetup(instance)
    }
}
```

## render中的emit

还有一种方式是在template中调用

```typescript
<button @click="$emit('close')">关闭</button>
```

这种方式怎么注入instance.emit，template本质就是render函数（complier阶段后）

```typescript
function render(_ctx) {
  return h("button", {
    onClick: () => _ctx.$emit('close')
  }, "关闭")
}
```

所以就回到**组件代理(_ctx)**进行注入instance.emit

修改**publicPropertiesMap**

```typescript
// \packages\runtime-core\src\componentPublicInstance.ts
const publicPropertiesMap: Record<string, (i: ComponentInternalInstance) => any> = {
    // （$el一般是在生命中期中访问（_ctx/this.$el），template不会使用）
    // 当用户访问 this.$el 时，返回 instance.vnode.el
    $el: (i: ComponentInternalInstance) => i.vnode.el,
    // @emit 当用户访问 _ctx/this.$emit 时, 返回另一个函数
    $emit: (i: ComponentInternalInstance) => i.emit
    // $slots 后面会实现
    // $slots: (i) => i.slots
}
```