# 3.3.7 实现 Lifecycle Hooks

**Lifecycle Hooks** 是**在组件生命周期**的关键时刻（创建、挂载、更新、销毁）自动调用的回调函数。

它的**实现逻辑很简单**：把用户在setup中钩子执行的生命周期函数先**存起来**，等到特定的时间点再**拿出来执行**

**根据目前的进度：**只实现 2 个最核心的钩子`onBeforeMount`，`onMounted`  其他钩子都是一样的，只是调用时机不同，在后期的章节会同步实现

## 基础实现

第一步：扩展组件实例，注: 因为存在同一个组件多次调用`onMounted` 的情况，因此m/bm保存的时候保存为一个数组，**接受所有的用户回调函数**

```typescript
// packages/runtime-core/src/component.ts

export interface ComponentInternalInstance {
  // ... 其他属性
  // [新增] 生命周期钩子数组
  // bm = beforeMount, m = mounted
  bm: Function[] | null;
  m: Function[] | null;
}

export function createComponentInstance(
    vnode: VNode,
    parent: ComponentInternalInstance | null): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
			  // [新增] 初始化为空
        bm: null,
        m: null
    }
    }
```

第二步：实现注册逻辑 ，构建生命周期函数

```typescript
// packages\runtime-core\src\apiLifecycle.ts
import { ComponentInternalInstance, getCurrentInstance, setCurrentInstance } from "./component";

export const enum LifecycleHooks {
    BEFORE_MOUNT = "bm",
    MOUNTED = "m"
}

function injectHook(
    type: keyof ComponentInternalInstance,
    hook: Function,
    // 默认直接绑定到当前setup对应的组件
    target: ComponentInternalInstance = getCurrentInstance()
) {
    if (target) {
        const hooks: Function[] = target[type] || (target[type] = [])
        hooks.push(hook)
    }
    else {
        console.warn(`Function ${type} is called without current active component instance.`);
    }
}

//导出具体的api
export const onMounted = (hook: Function) => injectHook(LifecycleHooks.MOUNTED, hook)
export const onBeforeMount = (hook: Function) => injectHook(LifecycleHooks.BEFORE_MOUNT, hook)
```

第三步：在 Renderer 中对应位置执行

- 在渲染（`instance.render`）之前，检查并执行 `bm` (BeforeMount)
- 在挂载（`patch`）完成之后，检查并执行 `m` (Mounted)

```typescript
// \packages\runtime-core\src\renderer.ts
function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {
    const { proxy, bm, m } = instance

    // 此时 render 还没执行，DOM 也没生成【新增】
    if (bm) {
        invokeArrayFns(bm)
    }
    // 返回改组件的描述ui Vnode, 它本质也是vNode继续递归
    // 新增，既保证this是代理，同时也给render函数传入第一个实际参（保证也是代理）
    const subTreeVNode = instance.render!.call(proxy, proxy)

    // 继续递归
    patch(null, subTreeVNode, container, instance)

    //当 vnode 是组件 (Component) 时， 指向该组件渲染出的子树根节点的el
    // 比如假设vnode.render(), 执行的是h('div', null, h(Bar-组件))
    // 也就是说上层递归会进入到element的判断, 然后初始化el = div真实DOM
    // vnode的el当然是应该subTreeVNode.el=<div></div>
    initialVNode.el = subTreeVNode.el

    // 挂载结束 【新增】
    if (m) {
        invokeArrayFns(m)
    }
}
    
// 辅助函数：遍历执行数组中的函数
function invokeArrayFns(fns: Function[]) {
    for (const fn of fns) {
        fn()
    }
}
```