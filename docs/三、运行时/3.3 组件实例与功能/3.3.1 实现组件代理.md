# 3.3.1 实现组件代理

让我们回到一个经典的响应式例子：

```typescript
<template>
  <div>{{ count }}</div>
</template>

<script>
import { ref } from 'vue'
export default {
  setup() {
    // 定义一个响应式变量
    const count = ref(0)
    return { count }
  }
}
</script>
```

Complier 阶段进行编译：就是我们上一节的组件的setup函数和render函数

```typescript
//简化
App = {
	render(_ctx) {
	  // 编译器直接生成了读取 _ctx.count 的代码
	  return h("div", null, _ctx.count) 
	}
	setup() {
		// 定义一个响应式变量
    const count = ref(0)
    return { count }
	}
}
```

编译后的代码里写着 ( `_ctx.`count)，这个_ctx必须是setup返回的对象，这样才可以正常访问响应式，这样render函数包裹在effect函数里时才可以正确收集依赖

至于为什么编译期不直接**instance.setupState.msg，我认为有下面2个原因：**

- **组件的数据来源太复杂了，setup() 返回值** (`setupState`) -> `count` (响应式数据)，**父组件传参** (`props`) -> `title`  (响应式数据)，**全局属性** (`$el`, `$slots`) -> `$el`  (比如模板中写插槽名)
- **组件的实例化发生在runtime，从职责来看也不符合**

注：在真实的情况同时存在this的调用情况，**用户手写 render 函数**

```typescript
function render(_ctx) {
  return h("div", {}, this.count) 
}
```

综合上面的问题：**Runtime 的 Proxy出现了**

`instance.proxy` 就是一个**调度中心（Receptionist），去代替掉_ctx（this）**
当 `render` 函数执行 `_ctx.`count（`this.`count）时：

- **触发 get 拦截**：Proxy 拦截到了读取 count 的请求
- 按顺序查询： setupState、props、$el是否存在对于的响应式变量，返回第一个查找到的

## 基础实现

> 这里我们**先实现统一的代理，然后在组件render函数中调用**，其他部分到相应的节调用代理（只要使用到了this的部分都应该加入代理，比如生命周期，插槽…）
> 
- 创建代理处理逻辑

注：**因为 Proxy 的特性，如果 Trap（拦截器）里没有拦截某些操作，它会直接透传给目标对象，因此为了避免用户操作到底层对象**，Proxy的输入是 { _: instance }

```typescript
//\packages\runtime-core\src\componentPublicInstance.ts
import { ComponentInternalInstance } from "./component"

/**
 * 专门处理 $ 开头的公共属性
 * key: 用户访问的属性名 ($slot, $el)
 * value: 函数，接收 instance，返回具体的值
 */
const publicPropertiesMap: Record<string, (i: ComponentInternalInstance) => any> = {
    // （$el一般是在生命中期中访问（this.$el），template不会使用）
    // 当用户访问 this.$el 时，返回 instance.vnode.el
    $el: (i) => i.vnode.el,
    // $slots 后面会实现
    // $slots: (i) => i.slots
    // $emit等等
}

export const PublicInstanceProxyHandlers = {
    get(instance: ComponentInternalInstance, key: string) {
        const { setupState } = instance;

        // 检测setupState
        if (key in setupState) {
            return setupState[key]
        }

        // $ 开头的公共属性
        const publicProperty = publicPropertiesMap[key]
        if (publicProperty) {
            return publicProperty(instance)
        }

        //后续实现检测props
    }
}
```

- 修改组件实例

```typescript
//\packages\runtime-core\src\component.ts
// 组件实例 (内部使用的组件对象)
export interface ComponentInternalInstance {
    // --- 核心属性 ---
    vnode: VNode; // 当前组件的 vnode
    type: ComponentOptions; // 组件配置对象
    // --- 状态相关 ---
    setupState: any;        // setup 的返回值-一般是一个对象
    proxy: any, // 代理对象 【新增】
    // --- 内部方法（里面就是调用h方法 --- 返回组件的ui描述vnode） ---
    render: InternalRenderFunction | null;
}

export function createComponentInstance(vnode: VNode): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
        vnode,
        type: vnode.type as ComponentOptions,
        setupState: {},
        proxy: {},
        render: null
    }
    // 创建代理
    instance.proxy = new Proxy({ _: instance }, PublicInstanceProxyHandlers)
    return instance
}
```

- 修改 Renderer 绑定 `this`

```typescript
//packages\runtime-core\src\renderer.ts
function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {
    const { proxy } = instance
    // 返回改组件的描述ui Vnode, 它本质也是vNode继续递归
    // 新增，既保证this是代理，同时也给render函数传入第一个实际参（保证也是代理）
    const subTreeVNode = instance.render!.call(proxy, proxy)
    patch(null, subTreeVNode, container)
    initialVNode.el = subTreeVNode.el
}
```