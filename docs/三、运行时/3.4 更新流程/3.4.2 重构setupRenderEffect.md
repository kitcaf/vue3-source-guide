# 3.4.2 重构setupRenderEffect

> **组件级的中粒度响应式**

是谁在监听数据的变化？又是谁触发了更新？

setupRenderEffect，它是连接 **响应式系统**和 runtime-core更新的桥梁，**它的核心是通过响应式系统实现effect函数对组件的Render函数进行包裹，并继续执行递归处理**

注：我们之前的**setupRenderEffect（\packages\runtime-core\src\renderer.ts）是一个初版函数，本节对它升级**

```typescript
//**\packages\runtime-core\src\renderer.ts - 初版**
function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {
    const { proxy, bm, m } = instance
    if (bm) {
        invokeArrayFns(bm)
    }
    const subTreeVNode = instance.render!.call(proxy, proxy)
    patch(null, subTreeVNode, container, instance)
    initialVNode.el = subTreeVNode.el
    if (m) {
        invokeArrayFns(m)
    }
}
```

## 基础实现

我们先回顾一下effect函数特征：**立即执行一次传入函数（fn）- 意味着必须将之前写的内容都写入到fn函数, 等待依赖更新然后fn重新执行**

但fn**中的部分内容**是不用**更新阶段重新执行（生命周期: beforeMount、mounted等）**，本质上挂载阶段和更新阶段的逻辑是不同，因此会给组件实例设置一个**变量isMounted**

通过**isMounted来控制fn的不同的分支**

- isMounted = false 执行挂载逻辑
- isMounted = true 执行更新逻辑（核心就是执行instance.render!，其他都取消）

第一步：**设置组件属性,** 增加一个**isMounted和subTree（上一次的subTreeNode）**

```typescript
// packages\runtime-core\src\component.ts
export interface ComponentInternalInstance {
    // --- 核心属性 ---
    vnode: VNode; // 当前组件的 vnode
    type: ComponentOptions; // 组件实例对象
    // --- 状态相关 ---
    setupState: any;        // setup 的返回值-一般是一个对象
    proxy: any, // 代理对象
    props: any,
    slots: Record<string, Slot>
    parent: ComponentInternalInstance | null, // 只指向父组件实例
    provides: Record<string, object>,
    isMounted: Boolean, // 组件是否挂载 【新增】,
    subTree: VNode | null, //【新增】
    // --- 内部方法（里面就是调用h方法 --- 返回组件的ui描述vnode） ---
    render: InternalRenderFunction | null;
    emit: (...args: any) => void,
    // --- 生命周期相关 ---
    bm: Function[] | null, // onBeforeMounted
    m: Function[] | null, // onMounted
}

export function createComponentInstance(
    vnode: VNode,
    parent: ComponentInternalInstance | null): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
        vnode,
        type: vnode.type as ComponentOptions,
        setupState: {},
        proxy: {},
        props: null,
        slots: {},
        parent: parent,
        isMounted: false, // 【新增】
        subTree: null // 【新增】
        ...
    }
}
```

第二步：**重构 setupRenderEffect**

```typescript
// \packages\runtime-core\src\renderer.ts
function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {

    effect(() => {
        if (!instance.isMounted) { // 挂载
            const { proxy, bm, m } = instance
            if (bm) {
                invokeArrayFns(bm)
            }
            // 记得对instance.subTree赋值
            const subTreeVNode = (instance.subTree = instance.render!.call(proxy, proxy))

            patch(null, subTreeVNode, container, instance)

            initialVNode.el = subTreeVNode.el
            if (m) {
                invokeArrayFns(m)
            }
        } else { // 更新
            const { proxy } = instance
            const oldSubTreeNode = instance.subTree
            // 重新执行组件render
            const newSubTreeVNode = (instance.subTree = instance.render!.call(proxy, proxy))
            patch(oldSubTreeNode, newSubTreeVNode, container, instance)

        }
    })
}
```

注：关于为什么不使用instance.subTree===null来代替instance.isMounted的判断，原因是render函数是可能会返回null的情况的。如下：

```typescript
const Comp = {
  setup() {
    const show = ref(false);
    return { show };
  },
  render() {
    // 如果 show 为 false，组件渲染为空
    return this.show ? h("div", "hello") : null; 
  }
}
```

## 补充

这里补充**proxyRefs（响应式阶段已经实现过的）**对setup解包

```typescript
setup() {
		const count = ref(0);
    return { //这里需要**proxyRefs解包一下，后面的**this.count才可以真正返回到响应式变量
				    // 否则就是this.count.value。然而实际complier是不会解析多一个.value
         count 
    }
},
render() {
    return h("div", {}, String(this.count));
}
```

具体实现：
```typescript
// packages\runtime-core\src\component.ts
export function handleSetupResult(instance: ComponentInternalInstance, setupResult: any) {
    // setup 可能返回对象 (State) 
    if (typeof setupResult === 'object') {
        instance.setupState = proxyRefs(setupResult) //【新增】这里需要对对象解包
    }
    // 第二类组件render函数
    else if (typeof setupResult === 'function') {
        instance.render = setupResult
    }
    finishComponentSetup(instance)
}
```