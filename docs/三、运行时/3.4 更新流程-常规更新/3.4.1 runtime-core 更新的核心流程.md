# 3.4.1 runtime-core 更新的核心流程

在进入更新之前，我们回忆一下之前的主要的工作，就一句话：**初次渲染（Mount）**
想象你是一个画家，面对一张白纸（`container`）：

- **createApp**：你接到了任务，拿到了一张**图纸（由complier阶段形成的vnode结构）**。
- **patch (n1=null)**：你发现之前的画布是空的（`n1` 是 `null`）。
- **mountComponent/mountElement**：你开始从上到下、递归地把图纸上的内容画出来。
    - 如果是组件，就执行 `setup`，拿到 `render` 函数的返回值（`subTree`）。
    - 如果是元素，就 `document.createElement`，然后把属性填上去。
- **Finish**：画完了，此时由vDOM树成功构建了一个颗真正的DOM树。

现在的局限性：未来虽然你的数据（响应式对象）变了，但你的界面**完全不知道**。界面永远停留在第一帧，是一个**静态**的快照（**初始渲染的结果**）

**rtime-core 更新的核心流程**：当响应式数据变化时，界面自动变成新的模样

这不仅仅是“重画”，因为重画太慢了（清空 DOM 再重建）。我们需要做的是 **Patch（修补）**

**Runtime-core更新决定了vue更新的细粒度：组件级的中粒度响应式配合虚拟 DOM 的细粒度比对**

- **组件级的中粒度响应式：谁在监听数据变化？**

Vue 的响应式系统（Dependency Tracking）是以 **组件（Component）** 为边界，无论组件内部用了多少个数据，只要其中任何一个发生变化，**整个组件的 Render 函数都会重新执行**。也就是我们说的将**组件的Render函数放入effect函数中**

- **虚拟 DOM 的细粒度比对：谁在执行真正的 DOM 操作？**

虽然组件的 Render 函数重新执行生成了一棵全新的 VNode 树，**但 Vue 会拿着新树和旧树进行比对（Diff）只有真正发生变化了的节点才会执行对于的DOM操作**

| **维度** | **之前的流程 (Mount)** | **现在的流程 (Update)** |
| --- | --- | --- |
| **触发时机** | `app.mount()` 调用时，只执行一次。 | 响应式数据 (`ref/reactive`) 发生 Set 操作时触发。 |
| **输入参数** | `patch(null, n2, container)` **n1 是 null**。 | `patch(n1, n2, container)` **n1 是旧的 VNode**（上次渲染的）。 |
| **核心逻辑** | **全量创建**：直接创建 DOM 节点并插入。 | **对比更新 (Diff)**：对比 n1 和 n2，找出差异，只更新变化的 DOM 属性或节点。 |
| **数据流** | VNode -> DOM | New VNode vs Old VNode -> DOM Updates |