# 3.4.4 更新 element 的 props

对比新旧两个 Props 对象 (`oldProps` 和 `newProps`)，找出它们之间的差异，并应用到真实的 DOM 元素 (`el`) 上。三种情况：

- **修改**：key 两个对象都存在，但值变了 (`{id: 'a'} -> {id: 'b'}`)
- **新增**：key 在新对象里有，旧对象里没有 (`{} -> {id: 'a'}`)
- **删除**：key 在旧对象里有，新对象里没有 (`{id: 'a'} -> {}`)

执行两个循环：

- 遍历 newProps 对象：如果 `newProps[key]` 不等于 `oldProps[key]` ，这里既判断了key，也判断了val，因此说明**要么是新增要么是修改**
- 遍历 `oldProps` ，如果存在key不存在于newProps，那么**执行删除**

## 基础实现：

- 增加一个的 `patchProps` 函数，对三种情况进行判别

```tsx
// packages/runtime-core/src/renderer.ts
function patchProps(el, oldProps, newProps) {
    if (oldProps !== newProps) {
        // 1. 遍历新 props: 处理 [修改] 和 [新增]
        for (const key in newProps) {
            const prevProp = oldProps[key];
            const nextProp = newProps[key];

            if (prevProp !== nextProp) {
                // hostPatchProp 是 createRenderer 时传入的配置项
                // 它具体负责 DOM 的 setAttribute 或 removeAttribute
                // // 在3.2.8节已经实现了对应的DOM方法
                hostPatchProp(el, key, prevProp, nextProp);
            }
        }

        // 2. 遍历旧 props: 处理 [删除]
        // 如果旧的 props 不为空，才需要检测删除
        if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
                // 如果 key 在新 props 中不存在，说明被删除了
                if (!(key in newProps)) {
                    // 传入 null，让 hostPatchProp 执行移除操作
                    // // 在3.2.8节已经实现了对应的DOM方法
                    hostPatchProp(el, key, oldProps[key], null);
                }
            }
        }
    }
}

function patchElement(
    n1: VNode,
    n2: VNode,
    container: HostElement,
    parent: ComponentInternalInstance | null
) {
    // 将旧节点的真实 DOM 赋值给新节点
    const el = (n2.el = n1.el)
    const oldProps = n1.props || EMPTY_OBJ // 保证非空
    const newProps = n2.props || EMPTY_OBJ // 保存非空

    // 更新 Props （下一节） 【增加调用】
    patchProps(el as HostElement, oldProps, newProps)

    // 更新 Children （下一节）
}
```