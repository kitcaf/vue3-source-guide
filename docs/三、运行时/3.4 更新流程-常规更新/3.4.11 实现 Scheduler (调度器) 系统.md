# 3.4.11 **实现 Scheduler (调度器) 系统**

我们目前只在 **响应式系统（Reactivity）的2.1.6节** 层面实现了 Scheduler 的**基础能力**（即 `effect` 函数支持传入 `scheduler` 选项）

现在我们要使用2.1.6的基础能力进行完善**在运行时**彻底解决 **组件更新同步且贪婪的问题，即：**

```jsx
// 假设 count 是响应式的
for (let i = 0; i < 100; i++) {
    count.value++; 
}
```

- 如果我们在一个函数里修改了 `count.value++` 100 次。
- 我们的 `instance.update`（即组件渲染函数）就会被立即执行 100 次。
- **依然存在严重的性能问题**

因此：我们需要运行时阶段实现一个 **调度系统（Scheduler System）** 来充当交通指挥官。它的核心目标是 **异步更新（Asynchronous Update）** 和 **任务去重（Deduping）**

Vue 不希望数据变化时立即执行复杂的 DOM 更新（这会阻塞主线程），而是希望把更新操作**推迟**到当前同步代码执行完毕之后。**微队列中里面的任务就天然在这个顺序里（主线程执行完毕，立刻执行微队列里的所有任务，然后进行DOM渲染）**

原理：**利用 JavaScript 事件循环（Event Loop）中的微任务（Microtask）机制，将同步发生的多次数据变更合并为一次异步的界面更新。实现方式就是将组件更新函数放入到微队列就可以**

## 实现

- **微任务函数创建**，不要将**每一个组件函数都丢到微队列中**（太耗性能了），只需要同一个一个队列维护所有的组件更新函数，然后**构建一个执行队列中的所有函数的微队列任务函数就可以**

```jsx
// packages\runtime-core\src\scheduler.ts
const queue: any[] = []

// 最终微队列的任务函数（只需要将这个函数放入微队列里就可以）
function flushJobs() {
    let job;
    while ((job = queue.shift()) != undefined) {
        job && job()
    }
}
```

- 实现外界调度函数，供外界将**`instance.update` 放入队列中，加入去重。然后思考 直接** `nextTick（flushJobs）`  是否可以呢？

```jsx
// packages\runtime-core\src\scheduler.ts
export function queueJob(job: any) {
    // 去重，保证一个组件的更新函数只需一个
    if (!queue.includes(job)) {
        queue.push(job)
	      //  nextTick（flushJobs）
    }
}
```

- **锁与微任务创建，不能在**queueJob直接nextTick，如果这么做意味这组件更新queueJob都会导致执行flushJobs放入微队列中，其实是不合理的，**只需要保证一次事件循环的过程中flushJobs进入一次微队列就可以了，因为flushJobs会执行queue队列中的所有组件更新函数，因此这里有一个上锁机制**

```jsx
let isFlushPending = false

function queueFlush() {
    // 如果isFlushPending=true，表示当前事件循环已经flushJobs放入微队列里了
    if (isFlushPending) return
    isFlushPending = true
    nextTick(flushJobs)
}

// 最终微队列的任务函数
function flushJobs() {
    // 【修改新增】执行了微队列的函数，isFlushPending可以设置回false
    isFlushPending = false

    let job;
    while ((job = queue.shift()) != undefined) {
        job && job()
    }
}

export function queueJob(job: any) {
    // 去重，保证一个组件的更新函数只需一个
    if (!queue.includes(job)) {
        queue.push(job)
        // 执行调度到微队列【修改新增】
        queueFlush()
    }
}
```

- 调用调度：**主动更新，被动更新都要写上**

```jsx
// packages\runtime-core\src\renderer.t
function setupRenderEffect(
    instance: ComponentInternalInstance,
    initialVNode: VNode,
    container: HostElement) {
    instance.update = effect(() => {
        ...
    }, {
        scheduler: () => { //主动更新-调度
            queueJob(instance.update) // 将组件的渲染函数重新输入就可以
        }
    })
}

function updateComponent( 【被动更新】
    n1: VNode,
    n2: VNode,
    container: HostElement,
    parent: ComponentInternalInstance | null
) {
    // 复用组件实例 【重要】
    const instance = (n2.component = n1?.component!)
    if (shouldUpdateComponent(n1, n2)) {
        instance.next = n2 // 保存下一个状态的vNode
        queueJob(instance.update); // 【新增被动更新】执行组件更新操作，也是放入微队列中
    } else { // 不需要更新
        n2.el = n1?.el!
        instance.vnode = n2
    }
}
```

## 优化-任务排序

目前队列里的任务是先来后到的。但在 Vue 的组件树中，这会导致两个严重的问题：

（一）父子组件的更新顺序导致性能问题

父组件更新可能会改变传给子组件的 `props`。如果 **子组件先更新**：它使用旧的 props 渲染了一次（浪费）。然后 **父组件更新**：传递新的 props，导致子组件 **再次更新**（双重渲染）。性能浪费，甚至可能导致 UI 闪烁或状态不一致。

（二）无法跳过已卸载组件的更新

如果父组件更新期间决定卸载子组件（比如 `v-if="false"`）。如果不排序，子组件可能在队列前面，它会**先执行更新（报错或浪费）**，然后才被父组件卸载。

- 给组件增加唯一 ID ：因为创建的过程一定是父组件然后子组件，因此可以设置一个全局的id，越小的id，表示是更大的组件

```jsx
// D:\project\vue3-source-guide\packages\runtime-core\src\component.t
let uid = 0; // 全局 ID 计数器
export interface ComponentInternalInstance {
    uid: number; // 唯一标识 【新增】
}

export function createComponentInstance(
    vnode: VNode,
    parent: ComponentInternalInstance | null): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
		    ...
        uid: uid++, //【新增】
         ...
    }
```

- 将 ID 绑定到更新任务上，因为job是instance.update它是没有id

```jsx
 // packages\runtime-core\src\renderer.ts
 function setupRenderEffect(
        instance: ComponentInternalInstance,
        initialVNode: VNode,
        container: HostElement) {

        instance.update = effect(...)
        // 放在后面
        instance.update.id = instance.uid
    }
```

- 调度器执行前排序

```jsx
// packages\runtime-core\src\scheduler.ts
function flushJobs() {
    // 执行了微队列的函数，isFlushPending可以设置回false
    isFlushPending = false
    // 排序【新增】
    queue.sort((a, b) => a.id - b.id)
    let job;
    while ((job = queue.shift()) != undefined) {
        job && job()
    }
}
```