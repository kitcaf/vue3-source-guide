# 3.2.3 实现 `createRenderer` (渲染器工厂函数)

因为**渲染器Renderer** 是运行时的心脏, 它包括了挂载/更新等一系列的工作。vue3的架构还是同样使用`createRenderer` 工厂函数（**闭包与参数传递、非单例的灵活性、依赖倒置等好处**）创建渲染器

**createRenderer**是 Renderer 的核心入口函数

- 它接收一个 `options` 对象。这个对象包含了特定平台的操作方法（比如 `createElement`, `insert`, `remove` 等，本节暂时不实现
- 它返回一个对象，该对象包含 `createApp` 方法
- 内部实例化了  `patch`（初始化挂载vNode树 & diff算法更新vNode树）函数和`render`（渲染入口-就是调用patch函数）

**基础实现**

- 修改`createApp.t`

```typescript
//packages/runtime-core/src/apiCreateApp
export function createAppAPI(
    render
) {
    return function createApp(rootComponent) {
        return {
            // 核心挂载方法 rootContainer 挂载的DOM对象
            mount(rootContainer) {
                // 1. rootComponent 转换为虚拟节点
                const vnode = createVNode(rootComponent)
                ...
            }
        }
    }
}
```

- 实现 `renderer.ts` ，并在其内部定义 `render` 和 `patch` (初版更新方法)

```typescript
//packages/runtime-core/src/renderer.ts
export function createRenderer(option: any) {
    // render: 渲染入口 调用 patch，处理挂载逻辑
    function render(vnode: any, container: any) {
        patch(null, vnode, container)
    }

    //patch: 初始化挂载DOM树 & 核心 Diff 算法入口（比较更新DOM树）
    // n1 旧VNode（vNode树）- null 表示挂载
    // 表现形式上是节点但有children变量本质就是VNode树
    // n2 新VNode（vNode树）
    // contianer 容器 -真实的DOM元素，挂载到div 比如 <div id="app"></div>
    function patch(n1, n2, container) {
        //等待实现
    }

    return {
        createApp: createAppAPI(render)
    }
} // 在vue3的真实使用场景中createRenderer会被官方初始化，这样就可以直接使用createApp
```