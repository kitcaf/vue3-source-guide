# 实现 h 函数 & 完善 VNode (ShapeFlags)

## ShapeFlags (形状标记)

在3.1节我们已经知道VNode树是**组件和HTML 标签交织共存的结构，**因此为了标识它们最好的方式就是加入**标识符号**

为了表示vNode的节点类型，同时为了**极致的性能**和**代码的简洁，没有选择常规的0，1，2。而是通过二进制枚举（**位运算 (`&`, `|`)**）的方式进行标识节点类型**

**传统的做法：**

```tsx
// 每次更新都要运行这堆判断，既慢又难读，同时两种状态就需要设置更多的标志
if (typeof vnode.type === 'string') {
   if (Array.isArray(vnode.children)) { ... }
}
```

**二进制枚举系统：**

**（1）| << 二进制符号 叠加标志作用**

```tsx
const element = 1 // 0001 html 标志
const component = 1 << 1 // 0010 组件标志
const array_children = 1 << 2 // 0100 chilrden 是数组标志
那么 component | array_children = 0110(二进制)，通过|叠加状态，既标识组件又标识chilrden是数组
```

**（2）& 多重加速判断**

```tsx
if (0110 & component) //成立
if (0110 & array_children ) //成立
```

**基础实现**

- 定义 ShapeFlags

```tsx
//package/shared/scr/shapeFlags.ts
export const enum shapeFlags {
    //001 HTML 元素
    ELEMENT = 1,
    //010(左移一位) 有状态组件 (平时写的普通组件)
    STATEFUL_COMPONENT = 1 << 1,
    //0100 子节点是纯文本（vnode.children）- 递归树等的判断
    TEXT_CHILDREN = 1 << 2,
    //01000 子节点是数组
    ARRAY_CHILDREN = 1 << 3
}
```

- 升级 createVNode，**创建节点的那一刻**，把它的**类型**算出来，并通过二进制| 叠加状态标志

```tsx
//packages\runtime-core\src\vnode.t
import { shapeFlags } from "packages/shared/src/shapeFlags"

/**
 * createVNode
 * @param type // 组件对象类型 或 HTML 标签名 (如 'div')
 * @param props // 属性
 * @param children // 子节点
 */
export function createVNode(type: any, props?: any, children?: any) {
    const vnode = {
        type,
        props,
        children,
        shapeFlag: getShapeFlag(type),
        el: null // 将来挂载的真实节点,
    }

    // 叠加状态
    if (typeof children === "string") {
        vnode.shapeFlag |= shapeFlags.TEXT_CHILDREN
    } else if (Array.isArray(children)) {
        vnode.children |= shapeFlags.ARRAY_CHILDREN
    }
    return vnode
}

// 辅助函数：根据 type 类型判断基本 Flag
function getShapeFlag(type) {
  return typeof type === "string"
    ? ShapeFlags.ELEMENT
    : ShapeFlags.STATEFUL_COMPONENT;
}
```

## 实现h函数

它是 **Hyperscript** 的缩写。它是一个**辅助函数**，用来让开发者方便地创建 VNode。对`createVNode` 的一层封装
**基础实现**

```tsx
//packages\runtime-core\src\h.ts
import { createVNode } from "./vnode";
export function h(type: any, props?: any, children?: any) {
    createVNode(type, props, children)
}
```

### 疑惑

如下所示，此时就可以构建一系列的vode节点了。**那么这个输入数据怎么来的？** 在编译器（Compiler）阶段对所有的vue模板文件处理，**得出h的输入。**`runtime-core`**只负责“什么时候更新”、“怎么对比新旧节点(Diff)”、“组件生命周期”等纯逻辑**

```tsx
h('div', { id: 'box' }, [
      h('span', null, '我是手写出来的'),
      h('button', { onClick: () => console.log('click') }, '点我')
 ])
```