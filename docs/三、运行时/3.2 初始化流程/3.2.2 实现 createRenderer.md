# 实现 `createRenderer` (渲染器工厂函数)

因为**渲染器Renderer** 是运行时的心脏, 它包括了挂载/更新等一系列的工作。vue3的架构还是同样使用`createRenderer` 工厂函数（**闭包与参数传递、非单例的灵活性、依赖倒置等好处**）创建渲染器

**createRenderer**是 Renderer 的核心入口函数

- 它接收一个 `options` 对象。这个对象包含了特定平台的操作方法（比如 `createElement`, `insert`, `remove` 等，本节暂时不实现
- 它返回一个对象，该对象包含 `createApp` 方法
- 内部实例化了 `render`（渲染入口）和 `patch`（Diff 算法入口）函数

**基础实现**

- 补全 `vnode.ts` (作为基础数据)修改`createApp.ts`，可能发现这里有children，是否会递归处理，还没有到时候，后面在patch会详细处理。**createVNode的输入既可以是 普通的 HTML 标签名（字符串），也可以是 组件对象（对象），**它一次只创建一个**单一的节点对象，后面vnode树由render生成**

```tsx
//packages/runtime-core/src/vnode.ts
/**
 * createVNode
 * @param type  组件对象类型 或 HTML 标签名 (如 'div')
 * @param props  属性
 * @param children  子节点
 */
export function createVNode(type: any, props?: any, children?: any) {
    const vnode = {
        type,
        props
        children, 
        el: null 
    }
    return vnode
}
//packages/runtime-core/src/apiCreateApp
export function createAppAPI(
    render
) {
    return function createApp(rootComponent) {
        return {
            // 核心挂载方法 rootContainer 挂载的DOM对象
            mount(rootContainer) {
                // 1. rootComponent 转换为虚拟节点
                const vnode = createVNode(rootComponent)
                ...
            }
        }
    }
}
```

- 实现 `renderer.ts` ，并在其内部定义 `render` 和 `patch` (初版更新方法)

```tsx
//packages/runtime-core/src/renderer.ts
export function createRenderer(option: any) {
    // render: 渲染入口 调用 patch，处理挂载逻辑
    function render(vnode: any, container: any) {
        patch(null, vnode, container)
    }

    //patch: 核心 Diff 算法入口
    // n1 旧VNode（虚拟节点树）- null 表示挂载
    // 表现形式上是节点但有children变量本质就是VNode树
    // n2 新VNode（虚拟节点树）
    // contianer 容器 - 就是挂载的div
    function patch(n1, n2, container) {
        //等待实现
    }

    return {
        createApp: createAppAPI(render)
    }
} // 在vue3的真实使用场景中createRenderer会被官方初始化，这样就可以直接使用createApp
```