# 3.2.2 实现createVNode（很重要）

## vNode

**VNode (Virtual Node)** 是整个vue渲染引擎的**核心数据结构**，它是对视图（View）层级中某一个具体节点的 **平台无关性描述（只是描写视图），**它作为 **声明式代码**（Template/Render Function）与 **命令式操作**（DOM API）之间的**中间层**

**核心属性：**
 `VNode` 结构被复用于两种完全不同的实体：**普通元素（Element）** 和 **组件（Component），也就是说需要满足我们之前提的 ”**VNode树是是**组件和HTML 标签交织**在一起的结构“

（1）`type` (类型标识)

**它是 VNode 的身份 ID**，决定了运行时（Renderer）如何处理这个节点

- 对于普通元素，`type` 是 **字符串** (e.g., `"div"`, `"span"`)
- 对于组件; `type` 是 **对象** (e.g., `{ setup: ..., render: ... }`), 存储了组件对象本身的一系列的属性和方法，比如有我们常见的setup方法（模板中的script部分 - 里面含有响应式变量创建，runtime阶段处理）, 组件render函数（描述组件的Ui, 模板中的template部分），都是**由Complier阶段处理，不是现在哦😀**

（2）`shapeFlag` （下一节）为了对vNode的类型进行更精细化的区分，设置了这个属性，比如有状态的组件、函数组件、子元素的情况等。

（3）`children` (子节点数据)
子节点数据，`children` 里面装的通常都是下一级的 VNode 节点，注意，**如果Vnode本身是组件类型，那么`children` 存储的是插槽内容（本质还是下一级的 VNode 节点），并不表示组件本身的UI，而是由组件render函数得到即可**

（4）`el` (宿主节点引用)
`el` 是 Virtual DOM 连接 Real DOM 的 **唯一物理锚点，初始状态**：`null`（VNode 刚创建时，真实节点还没有初始化）。在 `mount` （patch函数）阶段，当真实节点被创建或找到后赋值

- 当 VNode 是普通元素 (Element) 时，指向自身，指向通过 `document.createElement(type)` 创建出来的那个具体的 DOM 对象
- 当 VNode 是组件 (Component) 时，代理指向（Proxy Reference），指向该组件渲染（组件render函数执行 - **下一小节介绍**）出的 **子树根节点（SubTree Root）** 的 `el`

**代码实现：**

- createVNode函数（部分属性随着教程一步一步完整）

```tsx
//packages/runtime-core/src/vnode.ts
/**
 * createVNode
 * @param type  （不要认为只是一个字符串）组件对象 或 HTML 标签名 (如 'div')
 * @param props  属性（比如class="hello"）
 * @param children  子节点
 */
export function createVNode(type: any, props?: any, children?: any) {
    const vnode = {
        type,
        props
        children, 
        el: null 
    }
    return vnode
}
```

## 实现h函数

它是 **Hyperscript** 的缩写。它是一个**辅助函数**，用来让开发者方便地创建 VNode。对`createVNode` 的一层封装

```tsx
//packages\runtime-core\src\h.ts
import { createVNode } from "./vnode";
export function h(type: any, props?: any, children?: any) {
    createVNode(type, props, children)
}
```

**生命周期：**

我们回看整个vNode，不知道你是否疑惑h的输入是什么？或者说vNode的childen哪里来的？因为本质上有了children，整个vNode就构建成功了，可以通过children访问一系列的vNode子节点（组件时通过组件render访问），**我觉得我可以思考一下vNode的生命周期**

- 生成：**root-vNode**是由**Complier阶段（下一大章）**编译后的**组件 `render` 函数（如下代码本质就返回h函数的执行结构，即返回vNode）**运行时生成（**所以请记住它的本质源头是在Complier阶段**）

```tsx
// App.vue
<div id="container">
  <p>我是文本</p>
  <ChildComponent title="你好">
    <span>这是插槽内容</span>
  </ChildComponent>
</div>
// **Complier阶段**  编译后的结果（简化版）
render() {
  return h('div', { id: 'container' }, [ // 1. 顶层 div
    h('p', null, '我是文本'),            // 2. 它的孩子自然就是数组里的这一项
    h(ChildComponent, { title: '你好' }, { // 3. 遇到组件
       default: () => h('span', null, '这是插槽内容') // 4. 它的孩子被编译成了插槽对象
    })
 ]) // ChildComponent的ui描述继续通过ChildComponent.render()获得，在下一步调用获得
```

- 初始化：在**runtime阶段（当前章）**通过patch 函数进**初始化**

$$
\text{Patch(VNode)} = \begin{cases} 
\text{如果是组件} \rightarrow \text{执行 组件render函数} \rightarrow \text{拿到子树(SubTree-组件ui描述)} \rightarrow \text{递归 Patch(SubTree)} \\
\text{如果是元素} \rightarrow \text{调用宿主API(如 document.createElement)} \rightarrow \text{创建真实 DOM}
\end{cases}
$$

- 更新：运行时：对比新旧vNode更新DOM（diff算法）

**综上所述：**虽然 Runtime 内部机制很复杂，但因为有 Compiler 的存在，开发者只需要写简单的模板，**Compiler 会负责生成完美的组件 `render` 函数，天然知道“谁是父、谁是子、谁是组件、谁是元素”安排得明明白白。**

## 组件render

 **组件render**目的是**描述组件ui**，本质就是调用**h函数构建当前组件的vNode**

（1）**区分渲染器的 Render 和 组件的 Render**

| 两种类型的Render | 作用 |
| --- | --- |
| 渲染器的 Render | **runtime阶段：它的工作是调度整个工程，负责指挥 `patch` 去挂载、更新、卸载节点** |
| 组件的 Render | **complier阶段：描述组件，调用了h函数，产生vNode** |

（2） **两类组件 render：Component.render 与 Setup 直接返回 Render**

**（1）Component.render ：常规方式就是vue模板的语法（挂载在组件上）**

```tsx
<script>
import { ref } from 'vue'
export default {
  setup() {
    const count = ref(0)
    return { count } // 返回对象（数据）
  }
}
</script>

<template>
  <div>{{ count }}</div>
</template>
// Complier 阶段转换
import { ref, h } from 'vue'
const __sfc__ = {
  // 1. setup 原封不动
  setup() {
    const count = ref(0)
    return { count }
  },
  
  // 2. Compiler 帮我们生成了 render 函数（表示组件的ui）
  // 它把 <template> 里的内容翻译成了 h 函数调用
  render(ctx) 
    return h("div", ctx.count)
  }
}

export default __sfc__
```

 **（2）Setup 直接返回 Render ：直接写 JSX 或手写 h 函数（挂载在setup方法上）**

```tsx
// MyComponent.jsx
export default {
  setup() {
    const count = ref(0)
   
    // 开发者自己返回渲染函数, 通过
    return () => <div>{count.value}</div>
  }
}
```