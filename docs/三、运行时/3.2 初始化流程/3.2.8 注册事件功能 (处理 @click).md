# 3.2.8 注册事件功能 (处理 @click)

**注册事件功能** 是指在 `patchProp` 的过程中，识别出那些**以 `on` 开头**的属性（如 `onClick`, `onMousedown`），并将其作为**事件监听器**添加到 DOM 元素上。其实也就是我们经常写的`@click` （语法糖），它通过complier阶段后进入runtime阶段前，vNode里面的props，健名就被转换为onClick。

核心：只要属性名是以 `on` 开头（并且后面跟大写字母），我就把它当做事件监听器，注册到 DOM 上。
**第一步：实现通用判断工具**

使用一个正则检查器，用来判断某个 key 是不是事件

```tsx
// \packages\shared\src\index.ts
// 判断是否以 on 开头，且第三个字符是大写
export const inOn = (key: string) => /^on[A-Z]/.test(key);
```

**第二步：升级 `patchProp` 逻辑**

```tsx
//packages\runtime-dom\src\index.ts
export function patchProp(
    el: HTMLElement,
    key: string,
    preVal: any,
    nextVal: any): void {
    // 处理事件属性
    if (inOn(key)) {
        //事件名：onClick -> click
        const event = key.slice(2).toLowerCase();
        el.addEventListener(event, nextVal)
    }
    // 处理普通属性
    else {
        if (nextVal == null) {
            el.removeAttribute(key);
        } else {
            // 设置新属性
            el.setAttribute(key, nextVal);
        }
    }
}
```

这里我们再补全一点，

- 初次挂载 (Mount)：**处理事件当前代码可以**（由**mountElement调用**）
- 更新阶段 (Patch)：后期更新节点（diff算法时）**如果更新某个key的事件函数。当前的代码就是导致key对应两个事件函数（内存泄露了，旧的事件处理函数还在运行）**

判断这两种情况根据preVal就可以了（**preVal在更新阶段时一定存在的**，并且会作为入参）

```tsx
if (inOn(key)) {
    //事件名：onClick -> click
    const event = key.slice(2).toLowerCase();
    if (preVal) { // 如果preVal存在移除之前的事件
        el.removeEventListener(event, preVal)
    }
    
    if (nextVal) {
        el.addEventListener(event, nextVal)
    }
}
```

## 优化

目前事件属性在更新阶段一定是会涉及两个操作：

- removeEventListener 移除事件
- addEventListener  新增事件

我需要告诉你的无论是removeEventListener 还是addEventListener 都会调用**底层DOM API，意味着频繁操作 DOM。是有开销的重操作**

解决方式：在浏览器底层，`addEventListener` 注册事件时，浏览器会记录传入函数的**内存引用地址，既然如此就可以构建一个包装器（Invoker），包装器的引用输入到**`addEventListener` （引用永远不变），**包装器保存调用真正的事件方法**，**浏览器调用Invoker就是调用真正的事件方法**

注意：

- 一个包装器对应一个属性，因此每一个element都要Map**<string, Invoker>**

**实现：**

- 定义类型

```tsx
//packages\runtime-dom\src\patchProp.ts
type EventValue = Function | undefined

/**
 * 事件包装器
 */
interface Invoker extends EventListener {
    value: EventValue
}

/**
 * 事件包装器对象-对某个特定的元素来说每个属性构建一个包装器
 */
interface HTMLElementWithVei extends HTMLElement {
    _vei?: Record<string, Invoker | undefined>
}
```

- 修改**patchProp**

```tsx
//packages\runtime-dom\src\patchProp.ts
export function patchProp(
    el: HTMLElementWithVei,
    key: string,
    preVal: any,
    nextVal: any): void {
    // 处理事件分支
    if (inOn(key)) {
        //事件名：onClick -> click
        const eventName = key.slice(2).toLowerCase();

        //初始化缓存，如果_vei不存在，那么对el._vei 赋值对象
        const invokers = el._vei || (el._vei = {})
        const existingInvoker = invokers[eventName];
        // 场景1：更新
        if (nextVal && existingInvoker) {
            existingInvoker.value = nextVal
        }
        // 场景2：挂载初始化
        else {
            // 新增事件
            if (nextVal) {
                const invoker = ((e: Event) => {
                    // 包装器就是执行invoker.value函数
                    invoker.value!(e)
                }) as Invoker

                invoker.value = nextVal
                invokers[eventName] = invoker
                el.addEventListener(eventName, invoker)
            }
            // nextVal null，existingInvoker 还存在
            // 说明是某种情况依赖更新，用户不想要这个事件
            // 一定要removeEventListener，因为现在是包装器引用不变
            // 否则：（1）继续执行（2）内存泄露
            else if (existingInvoker) {
                el.removeEventListener(eventName, existingInvoker)
                // 清空这个属性Invoker引用
                invokers[eventName] = undefined;
            }
        }
    }
		...属性分支不变
}
```