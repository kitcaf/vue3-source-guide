# 3.2.5 实现初始化 component 主流程

> 初始化**组件类型vNode（本质就是初始化组件render函数）**，转换为用户看得到的界面

**Component 初始化** 是指当 `patch` 发现当前处理的是一个 **组件（ui描述是普通的html标签和组件） (Component)** 时，去执行的一系列“开箱”操作（**初始化vNode组件类型的状态**）：

- **创建实例 (Instance)**：为组件分配一块内存，存props, slots, setupState 等数据。
- **设置组件 (Setup)**：执行用户写的 `setup()` 函数（执行-里面是有用户的响应式式变量），拿到数据，并确保组件有 `render` 函数。
- **执行渲染 (Render Effect)**：调用组件 `render` 函数得到子树 (**SubTree - 它的子vNode**)，并递归调用 `patch` 继续处理子树。

我们还是要知道为什么怎么做：

- **状态隔离**：组件是有状态的。同一个组件（比如 `<TodoItem />`）可能被用很多次，我们需要为每一次使用创建一个独立的 **Instance** 来保存它的状态，互不干扰。
- **驱动更新**：需要把 `render` 的执行包裹在一个副作用函数  `effect` 中（响应式系统章节已经实现过啦 ），这样的话就可以**依赖收集，依赖改变，render函数就可以更新**。这里其实可以发现**vue3的响应式的触发的粒度是组件级**，但是后面又因为diff算法使得最终的DOM更新是DOM节点级别。（**在内存与性能的极致权衡**）

**基础实现**

**第一步：创建组件逻辑**

```tsx
//\packages\runtime-core\src\component.ts
export function createComponentInstance(vnode: VNode): ComponentInternalInstance {
    const instance: ComponentInternalInstance = {
        vnode,
        type: vnode.type as ComponentOptions,
        setupState: {},
        render: null
    }
    return instance
}
```

- setupComponent：它是初始化的入口，主要负责脏活累活和路线选择（比如：函数式组件和**状态组件***的判断，我们这里就是默认状态组件-vue模板形成的）

```tsx
//\packages\runtime-core\src\component.ts
export function setupComponent(instance: ComponentInternalInstance) {
    // TODO: initProps, initSlots (后续章节实现)
    // 暂且只处理状态组件
    setupStatefulComponent(instance)
}
```

- setupStatefulComponent：构建上下文 & 执行。一定是有执行 `setup` （setup函数里面是有用户写的响应式变量，需要执行代码）

```tsx
//\packages\runtime-core\src\component.ts
export function setupStatefulComponent(instance: ComponentInternalInstance) {
    const Component = instance.type;
    const { setup } = Component
		// 一定是要执行setup()
    if (setup) {
        const setupResult = setup()
        handleSetupResult(instance, setupResult)
    } else {
        finishComponentSetup(instance)
    }
}
```

- handleSetupResult：归一化用户的返回值，用户的 `setup()` 返回值是非常灵活的，需要在这里进行标准化，这里要补充一点：关于**组件 render函数**

**最终这部分的实现：**

```tsx
export function handleSetupResult(instance: ComponentInternalInstance, setupResult: any) {
    // setup 可能返回对象 (State) 
    if (typeof setupResult === 'object') {
		    // vue模板的render函数都是在组件.render
        instance.setupState = setupResult
    }
    // 也可能返回函数 (Render) - 直接写 JSX 或手写 h 函数的用户不使用vue模板
    // TODO（后期处理）: 如果返回的是 function，那是 render 函数
    finishComponentSetup(instance)
}
```

- finishComponentSetup：兜底

```tsx
//\packages\runtime-core\src\component.ts
export function finishComponentSetup(instance: ComponentInternalInstance) {
    const Component = instance.type;

    // 如果 instance 上还没有 render，赋值 Component 里的 render
    if (!instance.render) {
        instance.render = Component.render!;
    }
}
```

**第二步：完善渲染器逻辑，将上一步的函数在**createRenderer中的patch中完成调用

```tsx
// packages\runtime-core\src\renderer.ts
export function createRenderer(option: any) {
    // render: 渲染入口 调用 patch，处理挂载逻辑
    function render(vnode: VNode, container: Element) {
        patch(null, vnode, container)
    }

    //patch: 核心 Diff 算法入口
    // 作用：（1）挂载（2）更新
    // n1 旧VNode（虚拟节点树）- null 表示挂载
    // 表现形式上是节点但有children变量本质就是VNode树
    // n2 新VNode（虚拟节点树）
    // contianer 容器 - 就是挂载的div
    function patch(n1: VNode | null, n2: VNode, container: Element) {
        const { shapeFlag } = n2
        // 处理组件vNode
        if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
            processComponent(n1, n2, container)
        }
        // 处理Element vNode
        if (shapeFlag & ShapeFlags.ELEMENT) {
		        // 如果这个节点是Element意味这要初始化真实DOM
            console.log("处理 Element");
        }
    }

    //  --- 组件处理流程 ---
    function processComponent(n1: VNode | null, n2: VNode, container: Element) {
        // 表示挂载
        if (n1 == null) mountComponent(n2, container)
    }

    function mountComponent(initialVNode: VNode, container: Element) {
        const instance = createComponentInstance(initialVNode)

        // 执行setup,此时instance.render已经被成功赋值了
        setupComponent(instance)

        // 此时就是要执行instance.render，描述组件ui
        setupRenderEffect(instance, initialVNode, container)
    }

    function setupRenderEffect(
        instance: ComponentInternalInstance,
        initialVNode: VNode,
        container: Element) {
        // 返回该组件的描述ui Vnode, 它本质也是vNode，所有需要继续递归
        const subTreeVNode = instance.render!()

        // 继续递归
        patch(null, subTreeVNode, container)

        //当 vnode 是组件 (Component) 时， 指向该组件渲染出的子树根节点的el
        // 比如假设vnode.render(), 执行的是h('div', null, h(Bar-组件))
        // 也就是说上层递归会进入到element的判断, 然后初始化el = div真实DOM
        // vnode的el当然是应该subTreeVNode.el=<div></div>
        initialVNode.el = subTreeVNode.el
    }

    return {
        createApp: createAppAPI(render)
    }
}
```